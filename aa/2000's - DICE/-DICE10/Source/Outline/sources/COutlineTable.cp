/* -- History:(c) 2003 John Henry Thompson. All rights reserved.2003.03.26	jht		Based on PowerPlant example.*/// ===========================================================================// COutlineTable.cp			   ©1997-2002 Metrowerks Inc. All rights reserved.// ===========================================================================// Original Author: John C. Daub////	Subclass and concrete instantiation of LOutlineTable#include "COutlineTable.h"#include <LTableMultiGeometry.h>#include <LOutlineKeySelector.h>#include <LOutlineRowSelector.h>#include <LOutlineItem.h>#include <UAttachments.h>#include <CFBundle.h>#include <UNavServicesDialogs.h>//#include "CDirectoryItem.h"#include "CFileItem.h"#include "OutlineTableConstants.h"#include "CAppCommands.h"const SInt16	kColWidth		= 32000;// Forward references...static OSErr GetExecutableParentFSSpecFromBundle(FSSpecPtr theFSSpecPtr);static bool SelectFile(FSSpec &theFSSpec);static bool SelectFolder(FSSpec &theFSSpec);// --------------------------------------------------------------------------------// ConstructorCOutlineTable::COutlineTable(	LStream *inStream )		: LOutlineTable( inStream ){	// set the table geometry		SetTableGeometry(new LTableMultiGeometry(this, kColWidth, 20));		// set the table selector		SetTableSelector(new LOutlineRowSelector( this ) );		// and note that we don't set the table storage....		// most of the table classes not only maintain the graphical	// representation of your data but also the data itself. But	// LOutlineTable doesn't really do this...it mostly handles	// graphical representation... you need to handle your data	// maintenance elsewhere by yourself.		// insert a couple columns (name and size)		InsertCols( 1, 0, nil, nil, false );	// Set up keyboard selection and scrolling.	AddAttachment(new LOutlineKeySelector(this, msg_AnyMessage));	AddAttachment(new LKeyScrollAttachment(this));	// Try to become default commander in the window.	if (mSuperCommander != nil) {		mSuperCommander->SetLatentSub(this);	}}// --------------------------------------------------------------------------------// dtorCOutlineTable::~COutlineTable(){	// nothing}// --------------------------------------------------------------------------------// FinishCreateSelfvoidCOutlineTable::FinishCreateSelf(){	OSErr	err;	FSSpec	theFSSpec;		err = GetExecutableParentFSSpecFromBundle( &theFSSpec );	if (err)		goto exit;		AddFolder( theFSSpec );		exit:;}// --------------------------------------------------------------------------------LOutlineItem *COutlineTable::GetLastItem(){	LOutlineItem *lastItem = nil;	TableIndexT	rows, cols;		GetTableSize(rows, cols );	lastItem = FindItemForRow( rows);		return lastItem;}// --------------------------------------------------------------------------------LOutlineItem *COutlineTable::GetSelectedItem(){	STableCell		sel;	LOutlineItem *selItem = nil;	sel = GetFirstSelectedCell();	selItem = FindItemForRow(sel.row);	return selItem;}// --------------------------------------------------------------------------------voidCOutlineTable::AddFolder(FSSpec &theFSSpec){	LOutlineItem *theItem = nil;	LOutlineItem *lastItem = GetLastItem();	theItem = new CFileItem( theFSSpec, TRUE, 0 /* !!@ Need to fill in type */ );	ThrowIfNil_(theItem);		InsertItem( theItem, nil, lastItem );}// --------------------------------------------------------------------------------voidCOutlineTable::AddFile(FSSpec &theFSSpec){	LOutlineItem *theItem = nil;	LOutlineItem *lastItem = GetLastItem();	theItem = new CFileItem( theFSSpec, FALSE, 0 /* !!@ Need to fill in type */ );	ThrowIfNil_(theItem);		InsertItem( theItem, nil, lastItem );}// --------------------------------------------------------------------------------voidCOutlineTable::ExecuteSelection(){	CExecuteItem*	theItem;		theItem = (CExecuteItem*)GetSelectedItem();	if (theItem)	{		theItem->ExecuteScript();	}}// --------------------------------------------------------------------------------voidCOutlineTable::ListenToMessage(MessageT inMessage, void *ioParam){	FSSpec		theFSSpec;	bool		ok;		switch (inMessage)	{		case cmd_WorkspaceAddFile:		{						ok = SelectFile( theFSSpec );			if (ok)				AddFile( theFSSpec );		}		break;					case cmd_WorkspaceAddFolder:		{			ok = SelectFolder( theFSSpec );			if (ok)				AddFolder( theFSSpec );		}		break;					case cmd_WorkspaceAddRemove:		{			LOutlineItem*	theItem;						//theItem = FindItemForRow( 1 );			theItem = GetLastItem();			if (theItem)				RemoveItem( theItem );		}		break;					case cmd_WorkspaceExecute:		{			ExecuteSelection();		}		break;	}}// --------------------------------------------------------------------------------static OSErr GetExecutableParentFSSpecFromBundle(FSSpecPtr theFSSpecPtr){	OSErr err = fnfErr;	CFBundleRef myAppsBundle = CFBundleGetMainBundle();	//FSCatalogInfo	catInfo;	FSRef			parentRef;	FSCatalogInfo	catInfo;		if (myAppsBundle == NULL) return err;		CFURLRef myBundleURL = CFBundleCopyExecutableURL(myAppsBundle);		if (myBundleURL == NULL) return err;	FSRef myBundleRef;	Boolean ok = CFURLGetFSRef(myBundleURL, &myBundleRef);	CFRelease(myBundleURL);	if (!ok) return err;	err = FSGetCatalogInfo(&myBundleRef, kFSCatInfoNone, NULL, NULL, theFSSpecPtr, &parentRef);	if (err)		return err;		#if 1	err = FSGetCatalogInfo(&parentRef, kFSCatInfoNone, NULL, NULL, theFSSpecPtr, NULL);	#endif	#if 0		err = FSGetCatalogInfo(&parentRef, kFSCatInfoNodeID, &catInfo, NULL, theFSSpecPtr, NULL);	err = FSMakeFSSpec( theFSSpecPtr->vRefNum, catInfo.nodeID, "\pScripts", theFSSpecPtr);	#endif		return err;}// --------------------------------------------------------------------------------static bool SelectFile(FSSpec &theFSSpec){	OSType		inFileType = 'TEXT';	NavDialogOptionFlags	inFlags = kNavDefaultNavDlogOptions 		| kNavAllFilesInPopup 		| kNavSelectAllReadableItem;		//| kNavNoTypePopup;		//return UNavServicesDialogs::AskChooseOneFile(inFileType, theFSSpec, inFlags );	// AskChooseOneFile does not appear to honor show-me-everything option.	//	return UNavServicesDialogs::AskOpenOneFile(inFileType, theFSSpec, inFlags );}// --------------------------------------------------------------------------------static bool SelectFolder(FSSpec &theFSSpec){	SInt32		outFolderDirID;		return UNavServicesDialogs::AskChooseFolder(theFSSpec, outFolderDirID);}// ---------------------------------------------------------------------------------BooleanCOutlineTable::ObeyCommand(		CommandT			inCommand,		void*				ioParam){	Boolean		cmdHandled = true;	// Assume we'll handle the command	switch (inCommand) 	{		case cmd_WorkspaceExecute: 		{			ExecuteSelection();			break;		}		default: 		{			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;		}	}		return cmdHandled;}// ---------------------------------------------------------------------------------voidCOutlineTable::FindCommandStatus(	CommandT	inCommand,	Boolean&	outEnabled,	Boolean&	outUsesMark,	UInt16&		outMark,	Str255		outName){	switch (inCommand) {		case cmd_WorkspaceExecute: 		{			outEnabled = true;			break;		}		default: 		{			LCommander::FindCommandStatus(inCommand, outEnabled,											outUsesMark, outMark, outName);			break;		}	}}// --------------------------------------------------------------------------------// --------------------------------------------------------------------------------