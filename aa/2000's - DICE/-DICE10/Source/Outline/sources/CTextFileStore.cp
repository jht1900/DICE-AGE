/*2003.03.26	jht		Outline tabbed text file.*/#include "CTextFileStore.h"#include "CTextLineItem.h"#include "dicejs.h"#include <LFile.h>#include <UMemoryMgr.h>#include <LOutlineTable.h>// --------------------------------------------------------------------------------// constructorCTextFileStore::CTextFileStore(CFileItem *fileItem){	mFileItem = fileItem;}// --------------------------------------------------------------------------------// dtorCTextFileStore::~CTextFileStore(){}// --------------------------------------------------------------------------------static Handle GetHandleForFileSpec(const FSSpec&	inFileSpec){	// Create a new File object, read the entire File contents,			try 	{		StDeleter<LFile>	theFile(new LFile(inFileSpec));		//theFile->OpenDataFork(fsRdWrPerm);		theFile->OpenDataFork(fsRdPerm);		StHandleBlock textH(theFile->ReadDataFork());				return textH.Release();	}	catch (ExceptionCode inErr) 	{						// if it's the 32k problem, we won't rethrow here...but here		// (or rethrow and catch elsewhere to deal with it) would be the place		// to note this fact...a dialog to notify the user, etc.  In this		// demo, we'll just let the debugging macros suffice.				if (inErr != err_32kLimit) {			throw;		}	}	return 0;}// --------------------------------------------------------------------------------// lineEnd includes newLine if any// don't insert if zero charsvoid CTextFileStore::InsertOneLine( long lineCount, char *lineStart, char *lineEnd, CTextLineItemPtr &lastItem ){	long	lineLen;	Boolean canExpand = TRUE; // !!@ Need to compute by looking at next line		lineLen = lineEnd - lineStart + 1;	if (lineLen <= 0)		return;	InsertItemsAt(1, lineCount, lineStart, lineLen);		if (! CTextFileStore::IsWhiteChar( *lineStart ) 			&& ! CTextFileStore::IsNewLineChar( *lineStart ) )	{		CTextLineItem *theItem;				if (lastItem)			lastItem->mLineNumLast = lineCount - 1;					theItem = new CTextLineItem(this, lineCount, canExpand);		mFileItem->mOutlineTable->InsertItem( theItem, mFileItem, lastItem );				lastItem = theItem;	}}// --------------------------------------------------------------------------------void CTextFileStore::ExpandFirstLevel(){	Handle		hdl;	char*		lineEnd;	long		fileLen;	char*		lineStart;	long		lineCount;	CTextLineItem *lastItem = nil;		// Read the file contents into a handle	hdl = GetHandleForFileSpec( mFileItem->mFileSpec );	// Find the lines and create the first level outline items.	HLock( hdl );	lineEnd = (char *) *hdl;	fileLen = GetHandleSize( hdl );	lineCount = 1;	for (lineStart = lineEnd; fileLen > 0; fileLen--, lineEnd++)	{		if (*lineEnd == mNewLineChar)		{			// Include the newLine char			InsertOneLine( lineCount, lineStart, lineEnd, lastItem);			lineCount++;			//lineEnd++;			//fileLen--;			lineStart = lineEnd+1;		}	}	lineEnd--;	if (fileLen == 0)		InsertOneLine( lineCount, lineStart, lineEnd, lastItem);			if (lastItem)		lastItem->mLineNumLast = lineCount;		// !!@ Dispose of hdl}// --------------------------------------------------------------------------------void CTextFileStore::LoadScriptTextFile(){	Handle		hdl;	long		fileLen;	char*		lineStart;		// Read the file contents into a handle	hdl = GetHandleForFileSpec( mFileItem->mFileSpec );	// Find the lines and create the first level outline items.	HLock( hdl );	lineStart = (char *) *hdl;	fileLen = GetHandleSize( hdl );		#if 0	for (int i = 0; i < fileLen; i++)	{		if (lineStart[i] == '\r')			lineStart[i] = '\n';	}	#endif		dicejs_EvalStringPrint( lineStart, fileLen );		DisposeHandle( hdl );}// --------------------------------------------------------------------------------// --------------------------------------------------------------------------------