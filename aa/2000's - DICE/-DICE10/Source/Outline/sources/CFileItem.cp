// ===========================================================================// CFileItem.cp				   ©1997-2002 Metrowerks Inc. All rights reserved.// ===========================================================================// Original author: John C. Daub//// A concrete LOutlineItem for items of type "file"#include "CFileItem.h"#include "SendFinderOpen.h"#include <LOutlineItem.h>#include <LOutlineTable.h>#include <UGAColorRamp.h>#include "OutlineTableConstants.h"#include "GetFileIcon.h"#include "CTextFileStore.h"// --------------------------------------------------------------------------------// constructorCFileItem::CFileItem( FSSpec &inSpec, Boolean isFolder, OSType fdType ){	// store the FSSpec for the file associated with this item.		// Note that even tho we are storing data for an item within	// the outline item, this doesn't provide any sort of persistant	// storage of data within the table (see comments in COutlineTable's	// ctor about mTableStorage).		// The reason for this is how the outline table class deals with	// expansion and collapsing of hierarchical nodes... when you expand	// the item's ExpandSelf method is called (see CDirectoryItem for this	// as file items of course can't be expanded). And as things are expanded	// and such, items are created.. as collapsed, they are deleted. So	// there is no persistance of the outline items and their stored data.		// This is also why you might have a deep expansion of nested hierarchies	// in the table, but you collapse a top-level parent, reexpand that and	// the expand/nesting hierarchy is not maintained... everything was	// deleted and has to be recreated.		mFileSpec = inSpec;	mIsFolder = isFolder;	mFileType = fdType;	mTextFileStore = nil;		// get the icon for this file, use our defaults if we can't get one.		OSErr err = GetFileIcon(&inSpec, kSelectorAllAvailableData, &mIconH);	if ( (err == resNotFound) || (mIconH == nil) )	{		err = ::GetIconSuite( &mIconH, icon_Folder, kSelectorAllAvailableData );	}	ThrowIfOSErr_(err);		ThrowIfResFail_(mIconH);		::DetachResource(mIconH);		LString::CopyPStr(mFileSpec.name, mText);}// --------------------------------------------------------------------------------// dtorCFileItem::~CFileItem(){	if ( mIconH != nil ) 	{		::DisposeIconSuite(mIconH, true);	}	if (mTextFileStore)		delete mTextFileStore;}// --------------------------------------------------------------------------------// this is the routine called to know what to draw within the// table cell. See the comments in LOutlineItem.cp for more info.voidCFileItem::GetDrawContentsSelf(	const STableCell&		inCell,	SOutlineDrawContents&	ioDrawContents){	switch (inCell.col)	{		case 1:		{			ioDrawContents.outShowSelection = true;			ioDrawContents.outHasIcon = true;			ioDrawContents.outIconSuite = mIconH;			ioDrawContents.outTextTraits.style = 0;			if (mIsFolder)				ioDrawContents.outTextTraits.style |= bold;			ioDrawContents.outCanDoInPlaceEdit = true;									LString::CopyPStr( mText, ioDrawContents.outTextString);						break;		}	}}// --------------------------------------------------------------------------------// just to be cute, we'll draw an adornment (again, see the LOutlineItem.cp// comments for more information). We'll draw a groovy gray backgroundvoidCFileItem::DrawRowAdornments(	const Rect&		inLocalRowRect ){	ShadeRow(UGAColorRamp::GetColor(2), inLocalRowRect);}// --------------------------------------------------------------------------------// just to be cute, when a double-click occurs, we'll send the Finder// and open document AppleEvent to open our selected item... just to do// something.voidCFileItem::DoubleClick(	const STableCell&			/* inCell */,	const SMouseDownEvent&		/* inMouseDown */,	const SOutlineDrawContents&	/* inDrawContents */,	Boolean						/* inHitText */){	ThrowIfOSErr_(SendFinderOpenAE(&mFileSpec));}#if 0// --------------------------------------------------------------------------------// see how big the file actually is, and make a size string for printing// in the second columnvoidCFileItem::DetermineFileSize(){	HParamBlockRec pb;	Str255 fileName;	LString::CopyPStr( mFileSpec.name, fileName );		pb.fileParam.ioCompletion = nil;	pb.fileParam.ioNamePtr = fileName;	pb.fileParam.ioVRefNum = mFileSpec.vRefNum;	pb.fileParam.ioFVersNum = 0;	pb.fileParam.ioDirID = mFileSpec.parID;	pb.fileParam.ioFDirIndex = 0;		ThrowIfOSErr_(::PBHGetFInfoSync(&pb));		SInt32	dataForkSize = pb.fileParam.ioFlLgLen;	SInt32	rsrcForkSize = pb.fileParam.ioFlRLgLen;		SInt32	fileSize = dataForkSize + rsrcForkSize;	if ( fileSize >= 1024 ) {		fileSize /= 1024;				mSizeStr = fileSize;		mSizeStr += "\p K";	} else {				mSizeStr = fileSize;		mSizeStr += "\p bytes";	}}#endif// --------------------------------------------------------------------------------voidCFileItem::ExpandFolder(){	CInfoPBRec folderInfo;	Str31 dirFileName;	LString::CopyPStr( mFileSpec.name, dirFileName, sizeof(Str31) );		// find the info for this directory (mostly to get it's dirID)	folderInfo.hFileInfo.ioCompletion = nil;	folderInfo.hFileInfo.ioNamePtr = dirFileName;	folderInfo.hFileInfo.ioVRefNum = mFileSpec.vRefNum;	folderInfo.hFileInfo.ioFDirIndex = 0;	folderInfo.hFileInfo.ioDirID = mFileSpec.parID;	ThrowIfOSErr_(::PBGetCatInfoSync( &folderInfo ));	LOutlineItem *theItem = nil;	SInt16 index = 1;	LOutlineItem *lastItem = nil;		while ( true ) {			// and recurse through this folder to list its contents				CInfoPBRec fileInfo;		Str31 fileName;				fileInfo.hFileInfo.ioCompletion = nil;		fileInfo.hFileInfo.ioNamePtr = fileName;		fileInfo.hFileInfo.ioVRefNum = folderInfo.hFileInfo.ioVRefNum;		fileInfo.hFileInfo.ioFDirIndex = index++;		fileInfo.hFileInfo.ioDirID = folderInfo.hFileInfo.ioDirID;			OSErr err = ::PBGetCatInfoSync( &fileInfo );			if ( err != noErr )			break;						// we ignore invis stuff		if ( fileInfo.hFileInfo.ioFlFndrInfo.fdFlags & kIsInvisible )			continue;		// make an FSSpec for the file				FSSpec theSpec;				ThrowIfOSErr_(::FSMakeFSSpec( folderInfo.hFileInfo.ioVRefNum,						folderInfo.hFileInfo.ioDirID,						fileName,						&theSpec ));				// make an outline item based upon a directory or file				theItem = new CFileItem( theSpec, 						(fileInfo.hFileInfo.ioFlAttrib & ioDirMask) != 0,						fileInfo.hFileInfo.ioFlFndrInfo.fdType  );		ThrowIfNil_(theItem);			// and insert it at the end				mOutlineTable->InsertItem( theItem, this, lastItem );		lastItem = theItem;	}}// --------------------------------------------------------------------------------voidCFileItem::ExecuteScript(){	// !!@ Create only if not-null??	mTextFileStore = new CTextFileStore( this );		if (mTextFileStore)		mTextFileStore->LoadScriptTextFile();}// --------------------------------------------------------------------------------voidCFileItem::ExpandTextFile(){	mTextFileStore = new CTextFileStore( this );		if (mTextFileStore)		mTextFileStore->ExpandFirstLevel();}// --------------------------------------------------------------------------------// this is the magic of what we do when someone tries to// expand this item. We create outline items for all possible subitems.// We do not need to destruct these (in CollapseSelf) as that is// handled for us automatically.. see comments in LOutlineItem.cp for// more informationvoidCFileItem::ExpandSelf(){	if (mIsFolder)		ExpandFolder();	else if (mFileType == 'TEXT')		ExpandTextFile();}// --------------------------------------------------------------------------------// by default, rows are not expanders.. but since this is a directory// and we're showing hierarchy, of course we need to be able to expand.// So we must make sure the table is aware of that fact.BooleanCFileItem::CanExpand() const{		//return true;	return mIsFolder || (mFileType == 'TEXT');}// --------------------------------------------------------------------------------