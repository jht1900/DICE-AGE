// --------------------------------------------------------------------------------//// 2005.02.21	jht		Corrected expand by looking at next line.// 2003.03.26	jht		Outline tabbed text file.//// Copyright (c) 2005 John Henry Thompson. All rights reserved.// --------------------------------------------------------------------------------#include "CTextLineItem.h"#include "dicejs.h"#include <LOutlineItem.h>#include <LOutlineTable.h>#include <UGAColorRamp.h>// --------------------------------------------------------------------------------// constructorCTextLineItem::CTextLineItem(CTextFileStore *textFileStore, int lineNum, Boolean canExpand  ){	mTextFileStore = textFileStore;	mLineNum = lineNum;	mLineNumLast = lineNum;	mCanExpand = canExpand;	// !!@ CEditItem should query super class for string.	//	UInt32			ioItemSize = 255;		mTextFileStore->FetchItemAt( mLineNum, &mText[1], ioItemSize);	mText[0] = (char)ioItemSize;}// --------------------------------------------------------------------------------// dtorCTextLineItem::~CTextLineItem(){}// --------------------------------------------------------------------------------// this is the routine called to know what to draw within the// table cell. See the comments in LOutlineItem.cp for more info.voidCTextLineItem::GetDrawContentsSelf(	const STableCell&		inCell,	SOutlineDrawContents&	ioDrawContents){	ioDrawContents.outShowSelection = true;	//ioDrawContents.outHasIcon = true;	//ioDrawContents.outIconSuite = mIconH;	ioDrawContents.outTextTraits.style = 0;	ioDrawContents.outCanDoInPlaceEdit = true;		#if 0	// !!@ CEditItem should query super class for string.	//	UInt32			ioItemSize = 255;		mTextFileStore->FetchItemAt( mLineNum, &mText[1], ioItemSize);	mText[0] = (char)ioItemSize;	#endif		LString::CopyPStr( mText, ioDrawContents.outTextString);}// --------------------------------------------------------------------------------// just to be cute, we'll draw an adornment (again, see the LOutlineItem.cp// comments for more information). We'll draw a groovy gray backgroundvoidCTextLineItem::DrawRowAdornments(	const Rect&		inLocalRowRect ){	//ShadeRow(UGAColorRamp::GetColor(2), inLocalRowRect);}// --------------------------------------------------------------------------------voidCTextLineItem::DoubleClick(	const STableCell&			/* inCell */,	const SMouseDownEvent&		/* inMouseDown */,	const SOutlineDrawContents&	/* inDrawContents */,	Boolean						/* inHitText */){		//ThrowIfOSErr_(SendFinderOpenAE(&mFileSpec));}// --------------------------------------------------------------------------------// this is the magic of what we do when someone tries to// expand this item. We create outline items for all possible subitems.// We do not need to destruct these (in CollapseSelf) as that is// handled for us automatically.. see comments in LOutlineItem.cp for// more informationvoidCTextLineItem::ExpandSelf(){	char	str[255];	UInt32	strLen;	int		lineNum;	CTextLineItem *lastItem = nil;	CTextLineItem *theItem;	LOutlineTable *outlineTable = mTextFileStore->mFileItem->mOutlineTable;	//char		indentChar;	//int			lastLineNum = mTextFileStore->GetCount();	UInt16		parentIndentDepth = mTextFileStore->mFileItem->mIndentDepth;	UInt16		myRelDepth = mIndentDepth - parentIndentDepth;	char		ch;	Boolean canExpand = TRUE; // !!@ Need to compute by looking at next line	Boolean	lookingForHead = TRUE;		lineNum = mLineNum + 1;		for (; lineNum <= mLineNumLast; lineNum++)	{		strLen = 255;		mTextFileStore->FetchItemAt( lineNum, &str, strLen); 		//indentChar = str[0];		if (lookingForHead)		{			lookingForHead = (strLen <= 0) || CTextFileStore::IsNewLineChar( str[0] ) ;			for (myRelDepth = 0; myRelDepth < strLen; myRelDepth++)			{				ch = str[myRelDepth];				if (! CTextFileStore::IsWhiteChar( ch ) )					break;			}			goto InsertChild;		}		if (myRelDepth >= strLen)		{			goto InsertChild;		}					ch = str[myRelDepth];		if (! CTextFileStore::IsWhiteChar( ch ) )		{InsertChild: ;			if (lastItem)				lastItem->mLineNumLast = lineNum - 1;							//theItem = new CTextLineItem(mTextFileStore, lineNum, canExpand);			theItem = new CTextLineItem(mTextFileStore, lineNum, TestCanExpand(lineNum, myRelDepth) );			outlineTable->InsertItem( theItem, this, lastItem, myRelDepth );						lastItem = theItem;		}	}	if (lastItem)		lastItem->mLineNumLast = lineNum - 1;}// --------------------------------------------------------------------------------BooleanCTextLineItem::TestCanExpand( int lineNum, int relDepth ){	char	str[255];	UInt32	strLen;	Boolean	itemExists;	char		ch;		lineNum++;	relDepth;	strLen = 255;	itemExists = mTextFileStore->FetchItemAt( lineNum, &str, strLen);	if (! itemExists)		return FALSE;		if (relDepth > strLen)		return FALSE;		ch = str[relDepth];	return CTextFileStore::IsWhiteChar( ch );}// --------------------------------------------------------------------------------// by default, rows are not expanders.. but since this is a directory// and we're showing hierarchy, of course we need to be able to expand.// So we must make sure the table is aware of that fact.BooleanCTextLineItem::CanExpand() const{		//return true;	return mCanExpand;}// --------------------------------------------------------------------------------voidCTextLineItem::ExecuteScript(){	dicejs_EvalStringPrint( (char*)&mText[1], mText[0] );}// --------------------------------------------------------------------------------