// ===========================================================================// SCFinderUtility.cp// ===========================================================================// © 1995 James Kaput, Jeremy Roschelle SimCalc Project#include "SCFinderUtility.h"void	UFinder::GetAppSpec(FSSpec &inSpec){	ProcessSerialNumber	psn;	ProcessInfoRec		info;	info.processAppSpec = &inSpec;	info.processInfoLength = sizeof(info);	info.processName = nil;	::GetCurrentProcess(&psn);	::GetProcessInformation(&psn,&info);  }long UFinder::GetFolderID(FSSpec &inParentFolder, Str255 inName){		CInfoPBRec	pb;		// 108-byte area	DirInfo	*dpb = (DirInfo *)&pb;	OSErr 	err;	dpb->ioNamePtr = inName ;	dpb->ioVRefNum = inParentFolder.vRefNum;	dpb->ioDrDirID = inParentFolder.parID;	dpb->ioFDirIndex = 0;	err = PBGetCatInfoSync(&pb);	if (err == noErr && dpb->ioFlAttrib & ( 1 <<  4)) // make sure its a folder		return dpb->ioDrDirID;	else return 0;}OSErrUFinder::SendFinderAEOpen(FSSpec &inFile){	OSErr		err = noErr;	AEDesc		processDesc;	AppleEvent		ae, aeReply;	ae.descriptorType = aeReply.descriptorType = processDesc.descriptorType = typeNull;	ae.dataHandle = aeReply.dataHandle = processDesc.dataHandle = nil;		try {		DescType	finderType = 'MACS';		err = ::AECreateDesc(typeApplSignature,&finderType,sizeof(DescType),&processDesc);		FailOSErr_(err);				err	= ::AECreateAppleEvent(kCoreEventClass, kAEOpen,&processDesc,	                      				    kAutoGenerateReturnID,kAnyTransactionID,&ae);		FailOSErr_(err);				err = ::AEPutParamPtr(&ae,keyDirectObject,typeFSS,&inFile,sizeof(inFile));		FailOSErr_(err);		err  = ::AESend(&ae,&aeReply, kAENoReply | kAENeverInteract, kAENormalPriority,					kAEDefaultTimeout,nil,nil);		FailOSErr_(err);	}	catch (const LException& catchErr) {err = catchErr.GetErrorCode();}		if (processDesc.descriptorType != typeNull) ::AEDisposeDesc(&processDesc);	if (ae.descriptorType != typeNull) ::AEDisposeDesc(&ae);	if (aeReply.descriptorType != typeNull) ::AEDisposeDesc(&aeReply);	return err;}StFolderIterator::StFolderIterator(short inVRefNum, long inFolderID)	: mVRefNum(inVRefNum), mFolderID(inFolderID), mIndex(0){}Boolean	StFolderIterator::Next(HFileParam &ioRec){	ioRec.ioVRefNum = mVRefNum;	ioRec.ioDirID = mFolderID;	if (ioRec.ioNamePtr) ioRec.ioNamePtr[0] = 0; // reset name field	ioRec.ioFDirIndex = ++mIndex;	ioRec.ioResult = noErr;		PBHGetFInfoSync((HParmBlkPtr)&ioRec);	return  (ioRec.ioResult == noErr);}