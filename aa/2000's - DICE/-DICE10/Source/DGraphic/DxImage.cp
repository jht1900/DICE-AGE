// --------------------------------------------------------------------------------//// Image - wrap gworld//// 2005.02.21 	jht		Created.//// Copyright (c) 2005 John Henry Thompson. All rights reserved.// --------------------------------------------------------------------------------#include "DxImage.h"#include "dicejs.h"// --------------------------------------------------------------------------------DxImage::DxImage(void *wrapperObj, int pixelDepth, Rect aRect, ResIDT ctableID  )	: DxSurface(wrapperObj ){		this->gworldPtr = CreateGWorldForDepth(  pixelDepth,  aRect,  ctableID );}// --------------------------------------------------------------------------------DxImage::~DxImage(){	Close();}// --------------------------------------------------------------------------------void DxImage::Process( ){	}// --------------------------------------------------------------------------------Boolean DxImage::GetProp( DxPropID propId, DxPropType propType, void **outResult ){	switch (propId)	{		case kDxProp_value:		{			switch (propType)			{				case kDxType_GWorldPtr:				case kDxType_CGrafPortPtr:					if (outResult)						*outResult = this->gworldPtr;					return TRUE;									case kDxType_DxSurface:				case kDxType_DxImage:					if (outResult)						*outResult = this;					return TRUE;			}			break;		}	}	if (outResult)		*outResult = 0;	return FALSE;}// --------------------------------------------------------------------------------Boolean DxImage::SetProp( DxPropID propId, DxPropType propType, void *newValue ){	return FALSE;}// ---------------------------------------------------------------------------------GWorldPtr DxImage::CreateGWorldForDepth(int pixelDepth, Rect aRect, ResIDT ctableID  ){	CTabHandle ctable = 0;	QDErr				err;	GDHandle			aGDevice = 0;	GWorldFlags			flags = 0;	PixMapHandle		pixMapHd;	GWorldPtr			gworldPtr;	StGrafPortSaver		savePort;	if (ctableID)		ctable = GetCTable(ctableID);		gworldPtr = 0;			err = NewGWorld( &gworldPtr, pixelDepth, &aRect, ctable, aGDevice, flags);	if (gworldPtr)	{		pixMapHd = GetGWorldPixMap(gworldPtr);		LockPixels( pixMapHd );	}		if (ctable)	{		DisposeCTable( ctable );	}		return gworldPtr;}// ---------------------------------------------------------------------------------void DxImage::GetPixBaseInfo(UInt8** basePtr, int *rowBytes, Rect *bounds, int *pixelSize){	PixMapHandle		pixMapHd;	//this->gworldPtr->portPixMap;		pixMapHd = GetGWorldPixMap( this->gworldPtr );	if (! pixMapHd)	{		if (basePtr)			*basePtr = (UInt8*)0;		return;	}		if (basePtr)		*basePtr = (UInt8*)GetPixBaseAddr( pixMapHd );	if (rowBytes)		*rowBytes = (**pixMapHd).rowBytes & 0x3FFF;	if (bounds)		*bounds = (**pixMapHd).bounds;	if (pixelSize)		*pixelSize = (**pixMapHd).pixelSize;}// ---------------------------------------------------------------------------------int DxImage::GetWidth(){	PixMapHandle		pixMapHd;	Rect				box;	if (! this->gworldPtr)		return 0;		pixMapHd = GetGWorldPixMap(this->gworldPtr);	box = (**pixMapHd).bounds;	return box.right - box.left;}		// ---------------------------------------------------------------------------------int DxImage::GetHeight(){	PixMapHandle		pixMapHd;	Rect				box;	if (! this->gworldPtr)		return 0;		pixMapHd = GetGWorldPixMap(this->gworldPtr);	box = (**pixMapHd).bounds;	return box.bottom - box.top;}// ---------------------------------------------------------------------------------void DxImage::Close(){	if (this->gworldPtr)	{		DisposeGWorld( this->gworldPtr );	}	this->gworldPtr = 0;}// ---------------------------------------------------------------------------------// ---------------------------------------------------------------------------------