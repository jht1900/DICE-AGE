/* History:© 2001-2003 John Henry Thompson. All rights reserved.2003.03.10	jht It's been a while. Trying to make a sustained go at it this time.				Need to produce body of work and write about it. This will lead to				products, teaching opportunities and thus money.2001.05.24	jht	Use GetGraphicsImporterForFile2001.05.15	jht	Added AppleScript support.2000.12.??	jht	Created. Trying to find my way in a digital world.*/#include "CCapturePane.h"#include "CAppCommands.h"#include <LStaticText.h>#include <UDrawingState.h>#include <QDOffscreen.h>#include <Events.h>#include <ImageCompression.h>#include <UNavServicesDialogs.h>#include <UStandardDialogs.h>#include <Strings.h>#include <stdio.h>#include <string.h>#include "ResDef.h"#include "ControlDef.h"extern const ResIDT	PPob_ControlWindow;extern LWindow* theControlWindow;LStaticText*	theStatusText = 0;const ResIDT	kStatusTextView = 1021;const ResIDT	rCURS_Finger		= 1000;	static int		instanceCount = 0;FSSpec			CCapturePane::outFSSpec = {};int				CCapturePane::fileNum  = 0;//static int effSeq[] = { };#define kEffectMotionLastSeq 10// ---------------------------------------------------------------------------------//		¥ CCapturePane// ---------------------------------------------------------------------------------CCapturePane::CCapturePane(){}// ---------------------------------------------------------------------------------//		¥ CCapturePane(SPaneInfo&)// ---------------------------------------------------------------------------------CCapturePane::CCapturePane(	const SPaneInfo	&inPaneInfo )		: LPane( inPaneInfo){}// ---------------------------------------------------------------------------------//		¥ CCapturePane(const CCapturePane&)// ---------------------------------------------------------------------------------CCapturePane::CCapturePane(	const CCapturePane	&inOriginal )		: LPane( inOriginal ),		LCommander(inOriginal) {}// ---------------------------------------------------------------------------------//		¥ CCapturePane(LStream*)// ---------------------------------------------------------------------------------CCapturePane::CCapturePane(	LStream	*inStream )		: LPane( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CCapturePane// ---------------------------------------------------------------------------------CCapturePane::~CCapturePane(){	ReleaseBuffers();}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCCapturePane::FinishCreateSelf(){	loopTimePeriod = 0;	loopBoxesTimePeriod = 0;		convolutionFactor = 9;		loopFullDraw = 0;	loopFullDrawPeriod = 60;		loopBackImage = 0;	loopBackImagePeriod = 120;			imageBox = 0;	loopBoxes = 0;	loopBoxesRange = 4;		loopEffects = 0;	gwLastOutput = 0;	#if 1	inputDeviceNum = 1;	#else	inputDeviceNum = (instanceCount % 2) + 1 ;	#endif	instanceCount++;		grabStarted = 0;	effectNum = kEffectDirect;		mapIndex = 0;	mapCount = 15;	mapCount2 = 20;	mapDirection = 0;	lineMapStart = 0;	lineMapDest = 0;	lineMap = 0;		colorCycleNum = kColorCycleRandomBounce;	//colorCycleNum = kColorCycleRandomBright;	//colorCycleNum = kColorCycleRandom;		colorCycleCount = 30;	colorCycleIndex = 0;	int i;	for (i = 0; i < 3; i++)	{		colorCycleDelta[i] = 255 / colorCycleCount;		color[i] = 0;	}		blendLevel = 0x0FFFF;	inkMode = srcCopy;		diffTolerance = 40;	diffTolerance_x3 = diffTolerance*3;	menuVisible = 1;	captureScale = 1;	drawScale = 1;	//oldView = kEffectAverage;	stillScale = SCALE_FACTOR;	SeqGrabber = 0;	gwSourcePtr = 0;	gwPreviousPtr = 0;	gwMonitorPtr = 0;	gwPrevious2Ptr = 0;	gwBackPtr = 0;	gwBrushPtr = 0;	gwCompositePtr = 0;	gwAvgPtr = 0;	avgBufferPtr = 0;	gwOneBitPtr = 0;		StartIdling();		CreateBuffers();		CalcPortFrameRect( drawRect );		// Name windows thusly: w1, w2, ...	{		Str255		title;		WindowPtr	winp;				title[0] = 2;		title[1] = 'w';		title[2] = '0' + (instanceCount % 10);				winp = GetMacWindow();		if (winp)		{			::SetWTitle(winp,  title);		}	}		{		LWindow*	superView;				/* Our superior must be a window.		/ ?? Is their a safer way to get at our window?		*/		superView = dynamic_cast <LWindow *>( GetSuperView() );		if (superView)		{			superView->SetLatentSub( this );		}	}			countPixelBucket = (CountPixel*)NewPtr( sizeof(CountPixel) * kCountPixelBucketSize );	boxWalkEffect = new CBoxWalkEffect();	boxWalkEffect->outRect = drawRect;}// ---------------------------------------------------------------------------------void CCapturePane::ResizeBuffers(int newCaptureScale ){	ReleaseBuffers();		captureScale = newCaptureScale;		CreateBuffers();}// ---------------------------------------------------------------------------------void CCapturePane::ResetTimers(){	startTick = TickCount();	frameCount = 0;}// ---------------------------------------------------------------------------------void CCapturePane::CreateBuffers(){	CalcPortFrameRect( captureRect );	captureRect.right = captureRect.left + (captureRect.right - captureRect.left) / captureScale;	captureRect.bottom = captureRect.top + (captureRect.bottom - captureRect.top) / captureScale;		CreateGWorld(captureRect);		CreateSeqGrab(inputDeviceNum, captureRect, gwSourcePtr);		CreateAvgBuffer(captureRect);		CreateLineMap( captureRect.right - captureRect.left );		ResetTimers();}// ---------------------------------------------------------------------------------void CCapturePane::ReleaseBuffers(){	ComponentResult	result = noErr;		// Clean up	if (SeqGrabber != 0L)	{		result = CloseComponent (SeqGrabber);		SeqGrabber = 0L;	}		if (gwSourcePtr)	{		DisposeGWorld( gwSourcePtr );		gwSourcePtr = 0;	}		if (gwPreviousPtr)	{		DisposeGWorld( gwPreviousPtr );		gwPreviousPtr = 0;	}		if (gwMonitorPtr)	{		DisposeGWorld( gwMonitorPtr );		gwMonitorPtr = 0;	}		if (gwAvgPtr)	{		DisposeGWorld( gwAvgPtr );		gwAvgPtr = 0;	}	if (gwPrevious2Ptr)	{		DisposeGWorld( gwPrevious2Ptr );		gwPrevious2Ptr = 0;	}		if (gwBackPtr)	{		DisposeGWorld( gwBackPtr );		gwBackPtr = 0;	}		if (gwBrushPtr)	{		DisposeGWorld( gwBrushPtr );		gwBrushPtr = 0;	}		if (gwCompositePtr)	{		DisposeGWorld( gwCompositePtr );		gwCompositePtr = 0;	}		if (gwOneBitPtr)	{		DisposeGWorld( gwOneBitPtr );		gwOneBitPtr = 0;	}		if (gwMonitor8Ptr)	{		DisposeGWorld( gwMonitor8Ptr );		gwMonitor8Ptr = 0;	}	if (avgBufferPtr)	{		DisposePtr( (char *)avgBufferPtr );		avgBufferPtr = 0;	}		if (lineMapStart)	{		DisposePtr( (char *)lineMapStart );		lineMapStart = 0;	}	if (lineMapDest)	{		DisposePtr( (char *)lineMapDest );		lineMapDest = 0;	}	if (lineMap)	{		DisposePtr( (char *)lineMap );		lineMap = 0;	}}// ---------------------------------------------------------------------------------voidCCapturePane::CreateGWorld(Rect bounds){	/* Home of the digized bits */	gwSourcePtr = CreateGWorldForDepth( 32, bounds, 0);		/* Frame to difference against */	gwPreviousPtr = CreateGWorldForDepth( 32, bounds, 0 );			/* Computed motion image */	gwMonitorPtr = CreateGWorldForDepth( 32, bounds, 0 );		/* Secondary Previous Frame */	gwPrevious2Ptr = CreateGWorldForDepth( 32, bounds, 0 );	/* Background image  */	gwBackPtr = CreateGWorldForDepth( 32, bounds, 0 );		/* Brush image  */	gwBrushPtr = CreateGWorldForDepth( 32, bounds, 0 );		/* Composite image  */	gwCompositePtr = CreateGWorldForDepth( 32, bounds, 0 );		/* One bit for Black & White */	gwOneBitPtr = CreateGWorldForDepth( 1, bounds, 0 );		/* 8-bit world w/ rainbow palette */	gwMonitor8Ptr = CreateGWorldForDepth( 8, bounds, GetCTable( kRaindbowPalette ) );}// ---------------------------------------------------------------------------------void CCapturePane::ImportFileIntoGWorld( ConstStr255Param fileName, GWorldPtr gworldPtr, Rect bounds ){	FSSpec					fss;	short                  vRefNum = 0;	long                   dirID = 0;	OSErr					err;		err = FSMakeFSSpec( vRefNum, dirID, fileName, &fss);	ImportFileSpecIntoGWorld( fss, gworldPtr, bounds );}// ---------------------------------------------------------------------------------void CCapturePane::ImportFileSpecIntoGWorld( FSSpec &fss, GWorldPtr gworldPtr, Rect bounds){	GraphicsImportComponent gi = 0;	OSErr					err;	err = GetGraphicsImporterForFile(&fss, &gi);		GraphicsImportSetGWorld( gi, gworldPtr, 0);		GraphicsImportSetBoundsRect(gi, &bounds);		GraphicsImportDraw(gi);		CloseComponent(gi);}// ---------------------------------------------------------------------------------void CCapturePane::CreateAvgBuffer(Rect bounds){	/* Create Average gworld */	gwAvgPtr = CreateGWorldForDepth( 32, bounds, 0 );		/* Create array of floats for averaging */	{		int width, height, w, h;		AVG_TYPE *avgBufPtr;				width = (bounds.right - bounds.left) ;		height = (bounds.bottom - bounds.top) ;				avgBufferPtr = (AVG_TYPE *)NewPtr( sizeof(AVG_TYPE) * width * height * 3 );		for ( avgBufPtr = avgBufferPtr, w = 0; w < width; w++)		{			for (h = 0; h < height; h++)			{				*avgBufPtr++ = 0;				*avgBufPtr++ = 0;				*avgBufPtr++ = 0;			}		}			}}// ---------------------------------------------------------------------------------void CCapturePane::CreateLineMap( int width ){	lineMapStart = (int *)NewPtr( sizeof(int) * width );	lineMapDest = (int *)NewPtr( sizeof(int) * width );	lineMap = (int *)NewPtr( sizeof(int) * width );		int i;	int u;	int spread = 20;		for (i = 0;i < width; i ++)	{		lineMapStart[i] = i;		#if 0		lineMapDest[i] = width - i - 1;		#endif		#if 0		if (i < width/2)		{			u = i - spread;			if (u < 0) u = 0;			lineMapDest[i] = u;		}		else		{			u = i + spread;			if (u > width) u = width -1;			lineMapDest[i] = u;		}		#endif		u = (width-1)/2;		lineMapDest[i] = u;				lineMap[i] = i;	}}// ---------------------------------------------------------------------------------GWorldPtrCCapturePane::CreateGWorldForDepth(int pixelDepth, Rect aRect, CTabHandle ctable ){	QDErr				err;	GDHandle			aGDevice = 0;	GWorldFlags			flags = 0;	GWorldPtr			gwPtr;	PixMapHandle		pixMapHd;		StGrafPortSaver		savePort;	gwPtr = 0;			err = NewGWorld( &gwPtr, pixelDepth, &aRect, ctable, aGDevice, flags);	if (gwPtr)	{		pixMapHd = GetGWorldPixMap(gwPtr);		LockPixels( pixMapHd );	}		if (ctable)	{		DisposeCTable( ctable );	}		return gwPtr;}// ---------------------------------------------------------------------------------voidCCapturePane::CreateSeqGrab(int devNum, Rect bounds, GWorldPtr monitor){	ComponentDescription	theDesc;	ComponentResult			result = noErr;	GrafPtr					savedPort;	Component				sgCompID;		grabStarted = 0;	if (SeqGrabber != 0L)	{		result = CloseComponent (SeqGrabber);		SeqGrabber = 0L;	}	VideoChannel=0;	//SoundChannel=0;	//ActiveVideoRect;	//RecordVideo = 1;	//RecordSound = 1;	//SplitTracks = 0;	//SoundChannel = 0L;		// Find and open a sequence grabber	theDesc.componentType = SeqGrabComponentType;	theDesc.componentSubType = 0L;	theDesc.componentManufacturer = 'appl';	theDesc.componentFlags = 0L;	theDesc.componentFlagsMask = 0L;	sgCompID = FindNextComponent (nil, &theDesc);	if (sgCompID != 0L)		SeqGrabber = OpenComponent (sgCompID);		// If we got a sequence grabber, set it up	if (SeqGrabber != 0L)	{		// Get the monitor		// Monitor = GetMacPort();		if (monitor != nil)		{			// Display the monitor window			GetPort (&savedPort);						#if 0			MacSetPort ( (CGrafPtr) GetMacWindow () );			#endif						#if 1			MacSetPort (monitor);			#endif						// Initialize the sequence grabber			result = SGInitialize (SeqGrabber);			if (result == noErr)			{				#if 1				result = SGSetGWorld (SeqGrabber, (CGrafPtr) monitor, nil);				#endif								// Get a video channel				result = SGNewChannel (SeqGrabber, VideoMediaType, &VideoChannel);				if ((VideoChannel != nil) && (result == noErr))				{					#if 0					// ActiveVideoRect not used, caller drive bounds */					short	width;					short	height;										result = SGGetSrcVideoBounds (VideoChannel, &ActiveVideoRect);					width = (ActiveVideoRect.right - ActiveVideoRect.left) ;					height = (ActiveVideoRect.bottom - ActiveVideoRect.top)  ;					#endif					SeqGrabDataOutputEnum	opt;										opt = seqGrabPreview /* | seqGrabRecord | seqGrabPlayDuringRecord */ ;					result = SGSetChannelUsage (VideoChannel, opt );					result = SGSetChannelBounds (VideoChannel, &bounds);				}				SetInputDeviceNum( devNum );								#if 0				// Get a sound channel				result = SGNewChannel (SeqGrabber, SoundMediaType, &SoundChannel);				if ((SoundChannel != nil) && (result == noErr))				{					if (SoundChannel != nil)					{						result = SGSetChannelUsage (SoundChannel, seqGrabPreview | seqGrabRecord);												// Set the volume low to prevent feedback when we start the preview,						// in case the mic is anywhere near the speaker.						result = SGSetChannelVolume (SoundChannel, 0x0010);					}				}				#endif								#if 1				/* 2001.06.01 jht; Enable DV high quality (slow) preview */				result = SGSetChannelPlayFlags(VideoChannel, channelPlayHighQuality);				#endif								// Get the alignment proc (for use when dragging the monitor)				//result = SGGetAlignmentProc (SeqGrabber, &SeqGrabberAlignProc);			}						// Go!			#if 0			// 2001.05.24 jht: No don't go!			// for some odd reason starting a preview here will wack out the ports to 			// that alerts get draw to the off screen world.			// defer start preview until later			if (result == noErr)				result = SGStartPreview (SeqGrabber);			#endif							MacSetPort (savedPort);		}	}}// ---------------------------------------------------------------------------// Select an input device for video channel,// 1 selects the first available, 2 the second etc.void CCapturePane::SetInputDeviceNum( int aDevNum){	int 			devNum = aDevNum;	SGDeviceList	devList = 0;	Str63			devName;	ComponentResult			result = noErr;		if (! VideoChannel)		return;			result = SGGetChannelDeviceList( VideoChannel, 0, &devList );	if (! devList)		goto done;	int		index;		for (index = 0; index < (**devList).count; index++)	{		// Only count available devices		if (  ((**devList).entry[index].flags & sgDeviceNameFlagDeviceUnavailable) == 0 )		{			devNum--;			if (devNum <= 0)			{				BlockMove( &(**devList).entry[index].name, &devName, sizeof(devName));								result = SGSetChannelDevice( VideoChannel, devName );								inputDeviceNum = aDevNum;				goto done;			}		}	}	done:;	if (devList)	{		result = SGDisposeDeviceList( SeqGrabber, devList );	}}int CCapturePane::GetInputDeviceNum(){	if (! VideoChannel)		return 0;	return inputDeviceNum;}// ---------------------------------------------------------------------------//	¥ SpendTime								[public, virtual]// ---------------------------------------------------------------------------//	Idle time: Flash the insertion cursorvoidCCapturePane::SpendTime(	const EventRecord&	/* inMacEvent */){	ComponentResult	result = noErr;		StGrafPortSaver	savePort;		// 2001.05.24 jht: Do start here to prevent wacked out ports.	if (! grabStarted)	{		grabStarted = 1;		result = SGStartPreview (SeqGrabber);	}#if 1	if (SeqGrabber)	{		FocusDraw();				result = SGIdle (SeqGrabber);				UpdateFromGWorld();			}		UpdateStatus();#endif}// ---------------------------------------------------------------------------------static pascal BooleanSeqGrabberModalFilterProc (DialogPtr theDialog, const EventRecord *theEvent,	short *itemHit, long refCon){	// Ordinarily, if we had multiple windows we cared about, we'd handle	// updating them in here, but since we don't, we'll just clear out	// any update events meant for us		Boolean	handled = false;		theDialog;	itemHit;		if ((theEvent->what == updateEvt) && 		((WindowPtr) theEvent->message == (WindowPtr) refCon))	{		WindowPtr	wPtr = (WindowPtr) refCon;		BeginUpdate (wPtr);		EndUpdate (wPtr);		handled = true;	}		return (handled);}// ---------------------------------------------------------------------------------static voidVideoSettings( 	SeqGrabComponent SeqGrabber, SGChannel VideoChannel, WindowPtr winPtr){	SGModalFilterUPP	seqGragModalFilterUPP;	ComponentResult	err;		err = SGPause (SeqGrabber, true);		// Do the dialog thang	//seqGragModalFilterUPP = (SGModalFilterUPP)NewSGModalFilterProc( &SeqGrabberModalFilterProc);	// !!@ 2003.03.08 jht: No longer in Carbon. 	seqGragModalFilterUPP = 0;		err = SGSettingsDialog(SeqGrabber, VideoChannel, 0, 		nil, 0L, seqGragModalFilterUPP, (long)winPtr);			DisposeSGModalFilterUPP(seqGragModalFilterUPP);	err = SGPause (SeqGrabber, false);}	// ---------------------------------------------------------------------------------BooleanCCapturePane::ObeyCommand(		CommandT			inCommand,		void*				ioParam){	Boolean		cmdHandled = true;	// Assume we'll handle the command	switch (inCommand) 	{		case cmd_VideoSettings: 		{			if (SeqGrabber)			{				VideoSettings(SeqGrabber, VideoChannel, GetMacWindow());				//VideoSettings(SeqGrabber, VideoChannel, 0 );			}			break;		}		case cmd_SaveAs:		{			SaveImageAsNewFile();			break;		}		case cmd_SaveNext:		{			SaveImageAsNextFile();			break;		}		default: 		{			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;		}	}		return cmdHandled;}// ---------------------------------------------------------------------------------voidCCapturePane::FindCommandStatus(	CommandT	inCommand,	Boolean&	outEnabled,	Boolean&	outUsesMark,	UInt16&		outMark,	Str255		outName){	switch (inCommand) {		case cmd_VideoSettings: 		{			outEnabled = true;			break;		}		case cmd_SaveAs:		{			outEnabled = true;			break;		}		case cmd_SaveNext:		{			outEnabled = true;			break;		}		default: 		{			LCommander::FindCommandStatus(inCommand, outEnabled,											outUsesMark, outMark, outName);			break;		}	}}// ---------------------------------------------------------------------------------void	CCapturePane::UpdateStatus(){		frameCount++;	if (! theStatusText)	{		theStatusText = dynamic_cast <LStaticText *>( theControlWindow->FindPaneByID( kStatusTextView ) );	}	if (theStatusText)	{		char	buf[200];		float	lapse;		float	fps;				lapse =  ( TickCount() - startTick ) / 60.0 ;		fps = frameCount / lapse;				#if 0		long				KeyMap[4];		GetKeys(&KeyMap[0]);				sprintf( buf, "Frames=%d Lapse=%f FPS=%f %lx %lx %lx %lx", 			frameCount, lapse, frameCount / lapse, KeyMap[0], KeyMap[1], KeyMap[2], KeyMap[3] );		#endif		#if 0		sprintf( buf, "Frames=%d Lapse=%f FPS=%f still=%f", 			frameCount, lapse, frameCount / lapse, stillScale );		#endif		#if 0		sprintf( buf, "FPS=%f E=%d",  fps, effectNum);		#endif		#if 1		sprintf( buf, "%3.2f",  fps );		#endif				theStatusText->SetText(  buf, strlen(buf) );		//theStatusText->FocusDraw();	}}// ---------------------------------------------------------------------------------void CCapturePane::	CopyBitsEff (const BitMap *srcBits, const BitMap *dstBits, 			const Rect *srcRect,  const Rect *dstRect){	RGBColor	opColor;		opColor.red = blendLevel;	opColor.green = blendLevel;	opColor.blue = blendLevel;	OpColor( &opColor );		CopyBits(srcBits, dstBits, srcRect,  dstRect, inkMode, 0 /* maskRgn */ );}	// ---------------------------------------------------------------------------------void	CCapturePane::StepColorCycle(){	int i;		switch (colorCycleNum)	{		case kColorCycleGray:			for (i = 0; i < 3; i++)			{				color[i] += colorCycleDelta[i];			}			break;		case kColorCycleGrayBounce:		again:;			for (i = 0; i < 3; i++)			{				color[i] += colorCycleDelta[i];				if (color[i] > 255 || color[i] < 0)				{					colorCycleDelta[i] = - colorCycleDelta[i];					color[i] += colorCycleDelta[i];				}			}						break;		case kColorCycleRandom:			for (i = 0; i < 3; i++)			{				color[i] += (Random()&0x07FFF) % 255;			}			break;		case kColorCycleRandomBounce:			for (i = 0; i < 3; i++)			{				color[i] += colorCycleDelta[i];			}			colorCycleIndex++;			if (colorCycleIndex >= colorCycleCount)			{				int		color_target;								for (i = 0; i < 3; i++)				{					color_target = (Random()&0x7FFF) % 255;					colorCycleDelta[i] = (color_target - color[i]) / colorCycleCount;				}								colorCycleIndex = 0;			}			break;		case kColorCycleRandomBright:			for (i = 0; i < 3; i++)			{				color[i] = 0;			}			i = Random()&0x3;			if (i > 2) i = 2;			color[i] = 255;			break;	}	color_int[0] = color[0];	color_int[1] = color[1];	color_int[2] = color[2];}// ---------------------------------------------------------------------------------void	CCapturePane::StepEffects(){	long	now;		if (loopEffects)	{		now = TickCount();		if (now >= loopTimeLast)		{			loopTimeLast = now + loopTimePeriod;			effectNum = (effectNum + 1) % kEffectMotionLast;		}	}		if (loopBoxes)	{		now = TickCount();		if (now >= loopBoxesTimeLast)		{			loopBoxesTimeLast = now + loopBoxesTimePeriod;						{				boxWalkEffect->Step( this );			}					}	}	if (imageBox)	{		drawRect = boxWalkEffect->outRect;	}		if ( loopFullDraw )	{		now = TickCount();		if (now >= loopFullDrawTimeLast)		{			loopFullDrawTimeLast = now + loopFullDrawPeriod;						{				Rect	curRect;				CalcPortFrameRect( curRect );				drawRect = curRect;				boxWalkEffect->outRect = drawRect;			}		}	}	if ( loopBackImage )	{		now = TickCount();		if (now >= loopBackImageTimelast)		{			loopBackImageTimelast = now + loopBackImagePeriod;						{				SetDiffBackImage();			}		}	}}// ---------------------------------------------------------------------------------/* Copy raw digitized pixels to screen */void 	CCapturePane::CopyDirect(){	const BitMap	*pSource;	const BitMap	*pDest;	GrafPtr	myPort = GetMacPort();	pSource = GetPortBitMapForCopyBits( gwSourcePtr );	pDest = GetPortBitMapForCopyBits( myPort );	CopyBits( pSource, pDest, &captureRect, &drawRect, inkMode, 0);		gwLastOutput = gwSourcePtr;}// ---------------------------------------------------------------------------------void 	CCapturePane::UpdateFromGWorld(){	StepColorCycle();	StepEffects();		switch (effectNum)	{		case kEffectDirect:			CopyDirect();			break;		case kEffectAverage:			ComputeAverage();			break;		case kEffectMotionDiff:			ComputeMotionDiff();			break;		case kEffectMotionMoWhite:			ComputeMotionMoWhite();			break;		case kEffectMotionMoBlack:			ComputeMotionMoBlack();			break;		case kEffectMotionNoMoBlack:			ComputeMotionNoMoBlack();			break;		case kEffectMotionTrailWhite:			ComputeMotionTrailWhite();			break;		case kEffectMotionTrailImage:			ComputeMotionTrailImage();			break;		case kEffectMotionTrailColor:			ComputeMotionTrailColor();			break;		case kEffectMotionClampWhite:			ComputeMotionClampWhite();			break;		case kEffectMotionClampMax:			ComputeMotionClampMax();			break;		case kEffectMotionDiffGray:			ComputeMotionDiffGray();			break;		case kEffectMotionStreak:			ComputeMotionStreak();			break;		case kEffectMotionStreakColor:			ComputeMotionStreakColor();			break;		case kEffectMotionStreakColorTrail:			ComputeMotionStreakColorTrail();			break;		case kEffectLineMap:			ComputeLineMap();			break;		case kEffectMotionPaint:			ComputeMotionPaint();			break;		case kEffectBlackWhiteDiffusion:			ComputeBlackWhiteDiffusion();			break;		case kEffectCovMoTrailsColor:			ComputeCovMoTrailsColor();			break;					case kEffectCov8MoTrailsColor:			ComputeCov8MoTrailsColor();			break;					case kEffectMotionStreakEdge:			ComputeMotionStreakEdge();			break;					case kEffectMotionTransLayer:			ComputeTransLayer();			break;					case kEffectMotionColorMeter1:			ComputeAverage2();			ComputeColorMeter1();			break;					case kEffectMotionColorFreq:			ComputeColorFreq();			break;	}}// ---------------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------------voidCCapturePane::DrawSelf(){	ComponentResult	result = noErr;	#if 1	if (SeqGrabber)	{		result = SGUpdate( SeqGrabber, 0);				UpdateFromGWorld();				//result = SGIdle (SeqGrabber);	}		UpdateStatus();#endif}// ---------------------------------------------------------------------------------//		¥ ClickSelf// ---------------------------------------------------------------------------------voidCCapturePane::ClickSelf(	const SMouseDownEvent	&inMouseDown ){#pragma unused( inMouseDown )	// Just beep.	::SysBeep( 9 );	#if 0	VideoSettings(SeqGrabber, VideoChannel, GetMacPort());	#endif	#if 0	ComponentResult	result = noErr;		if (SeqGrabber)	{		result = SGUpdate( SeqGrabber, 0);				//result = SGIdle (SeqGrabber);	}#endif}#if 0// ---------------------------------------------------------------------------------//		¥ AdjustCursorSelf// ---------------------------------------------------------------------------------voidCCapturePane::AdjustCursorSelf(	Point				inPortPt,	const EventRecord	&inMacEvent ){#pragma unused( inPortPt, inMacEvent )	// Get the cursor.	CursHandle	theCursH = ::GetCursor( rCURS_Finger );	// Set the cursor.	if ( theCursH != nil ) ::SetCursor( *theCursH );}#endif// ---------------------------------------------------------------------------------void CCapturePane::ShowHideMenu(int menuVis){	GrafPtr	myPort = GetMacPort();	Rect	theRect;	RgnHandle	rgn;		if (! menuVis)	{		CalcPortFrameRect( theRect );				UnionRect( &theRect, &drawRect, &theRect);				rgn = NewRgn();				RectRgn(rgn, &theRect);				SetPortVisibleRegion( myPort, rgn );				DisposeRgn( rgn );				HideMenuBar();	}	else	{		ShowMenuBar();	}	menuVisible = menuVis;}// ---------------------------------------------------------------------------------void CCapturePane::SetEffectNum( int n){	effectNum = n;		ResetTimers();}int CCapturePane::GetEffectNum(){	return effectNum;}// ---------------------------------------------------------------------------------void CCapturePane::SetMeuVisible( int n){	ShowHideMenu( n!= 0 );}int CCapturePane::GetMeuVisible(){	return menuVisible;}// ---------------------------------------------------------------------------------void CCapturePane::SetDiffTolerance( int n){	diffTolerance = n;	diffTolerance_x3 = diffTolerance*3;}int CCapturePane::GetDiffTolerance(){	return diffTolerance;}// ---------------------------------------------------------------------------------void CCapturePane::SetStillFactor( int n){	stillScale = n;	if (stillScale <= 0)		stillScale = 1;}int CCapturePane::GetStillFactor(){	return stillScale;}// ---------------------------------------------------------------------------------void CCapturePane::SetCaptureScale( int n){	ResizeBuffers( n );}int CCapturePane::GetCaptureScale(){	return captureScale;}// ---------------------------------------------------------------------------------void CCapturePane::SetInk( int n){	inkMode = n;}int CCapturePane::GetInk(){	return inkMode;}// ---------------------------------------------------------------------------------void CCapturePane::SetBlend( int n){	n &= 255;	blendLevel = ( n << 8) || n;}int CCapturePane::GetBlend(){	return (blendLevel >> 8) & 255;}// ---------------------------------------------------------------------------------void CCapturePane::SetDrawRect( Rect rect){	drawRect = rect;}void CCapturePane::GetDrawRect(Rect &outRect){	outRect = drawRect;}// ---------------------------------------------------------------------------------void CCapturePane::SetColorCycleNum( int n){	int	i;		colorCycleNum = n;	switch (colorCycleNum)	{		case kColorCycleGray:		case kColorCycleGrayBounce:			for (i = 0; i < 3; i++)			{				colorCycleDelta[i] = 255 / colorCycleCount;				color[i] = 0;			}			break;		case kColorCycleRandom:			for (i = 0; i < 3; i++)			{				color[i] = Random() % 255;			}			break;		case kColorCycleRandomBounce:			colorCycleIndex = colorCycleCount;			break;	}}int CCapturePane::GetColorCycleNum(){	return colorCycleNum;}// ---------------------------------------------------------------------------------void CCapturePane::SetColorCycleCount( int n){	if (n < 0) n = 1;	colorCycleCount = n;	colorCycleIndex = colorCycleCount;}int CCapturePane::GetColorCycleCount(){	return colorCycleCount;}// ---------------------------------------------------------------------------------/* Copy current souce to previous2 */void CCapturePane::SetDiffBackImage(){	const BitMap	*pSource;	const BitMap	*pDest;	pSource = GetPortBitMapForCopyBits( gwSourcePtr );	pDest = GetPortBitMapForCopyBits( gwPrevious2Ptr );	CopyBits( pSource, pDest, &captureRect, &captureRect, srcCopy, 0);	#if 0	{				ImportFileIntoGWorld( "\pTiBo:DyMedia:-DICE Build:output:images:grass.jpg", gwBrushPtr, captureRect);				ImportFileIntoGWorld( "\pTiBo:DyMedia:-DICE Build:output:images:sky.jpg", gwCompositePtr, captureRect);	}	#endif}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetLoopBackImage( int state){	loopBackImage = state;}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetBackImagePeriod( int dur){	if (loopBackImagePeriod != dur)	{		loopBackImagePeriod = dur;		loopBackImageTimelast = TickCount();	}}// ---------------------------------------------------------------------------------/* Set composite buffer */void CCapturePane::SetBackImage( FSSpec &fss){	ImportFileSpecIntoGWorld( fss, gwCompositePtr, captureRect);}	// ---------------------------------------------------------------------------------/* Set composite buffer */void CCapturePane::SetBrushImage( FSSpec &fss){	ImportFileSpecIntoGWorld( fss, gwBrushPtr, captureRect);}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SaveGWorldToFSpec( GWorldPtr gWorld, FSSpec &fspec){	GraphicsExportComponent ge = 0;	OpenADefaultComponent(GraphicsExporterComponentType, 							kQTFileTypeJPEG, &ge);	GraphicsExportSetInputGWorld(ge, gWorld);	GraphicsExportSetOutputFile(ge, &fspec);	GraphicsExportDoExport(ge, nil);	CloseComponent(ge);}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SaveImageAsNewFile(){	//FSSpec		outFSSpec;	Str255		defaultName;		PP_StandardDialogs::LFileDesignator*	designator =								new PP_StandardDialogs::LFileDesignator;									designator->SetFileType( FOUR_CHAR_CODE('JPEG') );		if (designator->AskDesignateFile(GetDescriptor(defaultName))) 	{				designator->GetFileSpec(outFSSpec);				if (gwLastOutput)		{			SaveGWorldToFSpec( gwLastOutput, outFSSpec );						fileNum = 1;		}	}	}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SaveImageAsNextFile(){	char	baseNameBuf[256];	char	fullNameBuf[256];	FSSpec	fspec;			if (fileNum == 0)	{		SaveImageAsNewFile();		return;	}		p2cstrcpy( baseNameBuf, outFSSpec.name );	sprintf( fullNameBuf, "%s%03d.jpg",  baseNameBuf, fileNum);		fspec = outFSSpec;	c2pstrcpy( fspec.name, &fullNameBuf[0] );		if (gwLastOutput)	{		SaveGWorldToFSpec( gwLastOutput, fspec );				fileNum++;	}}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetLoopEffectDuration( int dur){	if (loopTimePeriod != dur)	{		loopTimePeriod = dur;		loopTimeLast = TickCount();	}}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetLoopEffects( int state){	loopEffects = state;}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetLoopBoxesDuration( int dur){	if (loopBoxesTimePeriod != dur)	{		loopBoxesTimePeriod = dur;		loopBoxesTimeLast = TickCount();	}}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetImageBox( int state){	imageBox = state;}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetLoopBoxes( int state){	loopBoxes = state;}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetFullDraw( ){	Rect	curRect;		CalcPortFrameRect( curRect );	drawRect = curRect;	boxWalkEffect->outRect = drawRect;}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetLoopFullDraw( int state){	loopFullDraw = state;}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetLoopFullDrawPeriod( int dur){	if (loopFullDrawPeriod != dur)	{		loopFullDrawPeriod = dur;		loopFullDrawTimeLast = TickCount();	}}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetBoxScale( int num){	boxWalkEffect->size = num;}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetConvolutionFactor( int num){	convolutionFactor = num;}// ---------------------------------------------------------------------------------/*  */void CCapturePane::SetPaletteNum( int num){	CTabHandle 		ctable = 0;	CTabHandle 		ctable2 = 0;	PixMapHandle	pixMapHd = 0;	//ColorSpec	*pColorSpec;	//ColorSpec	*pColorSpec2;		ctable = GetCTable( kPaletteResBase -1 + num );	if (! ctable)		goto exit;		pixMapHd = GetGWorldPixMap(gwMonitor8Ptr);		ctable2 = (**pixMapHd).pmTable;	(**pixMapHd).pmTable = ctable;		CTabChanged( ctable );		if (ctable2)	{		DisposeCTable( ctable2 );	}	exit:;}// ---------------------------------------------------------------------------------// ---------------------------------------------------------------------------------