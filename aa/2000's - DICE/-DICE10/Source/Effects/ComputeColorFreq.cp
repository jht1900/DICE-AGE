/* History:Copyright © 2001 John Henry Thompson. All rights reserved2002.02.12	jht	Part of color meter.2001.05.22	jht	Split off.*/#include "CCapturePane.h"// ---------------------------------------------------------------------------------static void quick_sort( int ifirst, int ilast, CountPixel* L){	int 		lo = ifirst;	int 		hi = ilast;    CountPixel		pivot;	int 		i, j;	int		bExchanged;		/* lists smaller than two elements don't need sorting ! */	if (hi <= lo)		return;	#define kMinDiff (kCountPixelBucketSize)	if ((hi - lo) <= kMinDiff )	{		/* This list is too small to warrent qsort(), or stack space is		/  limited, so we shouldn't recurse any more. Use a bubble sort. */				for (j = hi; j > lo; j--)		{			bExchanged = FALSE;			for (i = lo; i < j; i++)			{                if (  L[i].count > L[i+1].count )				{				    CountPixel swap;					/* swap entries i and j */					swap = L[i];					L[i] = L[i+1];					L[i+1] = swap;					bExchanged = TRUE;				}			}			/* the sort can exit early if a pass of the inner loop doesn't perform a swap */			if (!bExchanged)				break;		}		/* done the sort early, quit. */		return;	}	/* Pick a pivot and move it out of the way */	pivot = L[(lo + hi) / 2];    L[(lo + hi) / 2] = L[hi];	L[hi] = pivot;	while( lo < hi )	{		/* Search forward from a[lo] until an element is found that		/  is greater than the pivot or lo >= hi. */		while ( (L[lo].count <= pivot.count ) && lo < hi)			lo++;		/* Search backward from a[hi] until element is found that		/  is less than the pivot, or lo >= hi. */		while ( (pivot.count <= L[hi].count) && lo < hi)			hi--;		if( lo < hi )		{			CountPixel swap;			/* swap entries lo and hi */			swap = L[lo];			L[lo] = L[hi];			L[hi] = swap;		}	}	/* Put the pivot in the "center" of the list. */	L[ilast] = L[hi]; 	L[hi] = pivot;	/* Recursive calls, elements a[lo0] to a[lo-1] are less than or	/  equal to pivot, elements a[hi+1] to a[hi0] are greater than	/  pivot. */    quick_sort( ifirst, lo-1, L);    quick_sort( hi+1, ilast, L );}// ---------------------------------------------------------------------------------void	CCapturePane::ComputeColorFreq(){	const BitMap	*pSource;	const BitMap	*pDest;	GrafPtr	myPort = GetMacPort();	GrafPtr			savedPort;	PixMapHandle		pixMapHd;	int					hcount, vcount, width, height;	Rect				box;		UInt8*				srcPtr;		int					srcRowBytes;		UInt8*				srcLinePtr;		SInt32				pix, index;	CountPixel		*bucket;			pixMapHd = GetGWorldPixMap(gwSourcePtr);		srcPtr = (UInt8*)GetPixBaseAddr( pixMapHd );	srcRowBytes = (**pixMapHd).rowBytes & 0x3FFF;			box = (**pixMapHd).bounds;	width = box.right - box.left;	height = box.bottom - box.top;	//dstPtr += width*4;	for (index = 0; index < kCountPixelBucketSize; index++)	{		bucket = &countPixelBucket[index];		bucket->pixel = 0;		bucket->count = 0;	}		for (vcount = height; vcount > 0; vcount--, srcPtr += srcRowBytes)	{		srcLinePtr = srcPtr;		for (hcount =  width; hcount > 0; hcount--, srcLinePtr+=4)		{			pix = *(int*)srcLinePtr;			index = (((pix>>(16+3))&31)<<(5+5) ) | (((pix>>(8+3))&31)<<(5)) | ((pix>>(0+3))&31);			bucket = &countPixelBucket[index];			bucket->count++;			bucket->pixel = pix;		}	}	//quick_sort( 0, kCountPixelBucketSize-1, countPixelBucket);	//quick_sort( 0, 9000, countPixelBucket);		GetPort (&savedPort);	MacSetPort ( (CGrafPtr)gwCompositePtr );	short	h, v;	Rect	rt;	int		count;	RGBColor	rgb, rgbSave;	int			temp;		//GetForeColor( &rgbSave );	rgbSave.red = 0;		// Black	rgbSave.green = 0;	rgbSave.blue = 0;		h = 0;	v = 0;	for (index = 0; index < kCountPixelBucketSize; index++)	{		bucket = &countPixelBucket[index];		count = bucket->count;		pix = bucket->pixel;				rgb.red = ((pix>>16) & 255) << 8;		rgb.green = ((pix>>8) & 255) << 8;		rgb.blue = (pix&255) << 8;				RGBForeColor(&rgb);				if (count < 0)		{			DebugStr("\p count < 0");		}				for(; count > 0; )		{			rt.left = h;			rt.top = v;			rt.right = h + count;			rt.bottom = rt.top + 1;			if (h + count >= width)			{				rt.right = width;				v++;				h = 0;			}			else			{				h += count;			}			count -= (rt.right - rt.left);			if (rt.right - rt.left <= 0)			{				DebugStr("\p rt.right - rt.left <= 0");			}						PaintRect( &rt );		}		if (v >= height)		{			break;		}		if ( (index % 1000) == 0)		{			temp = index;		}	}	MacSetPort (savedPort);	RGBForeColor( &rgbSave );	#if 1	/* Draw averge */	pSource = GetPortBitMapForCopyBits( gwCompositePtr );	pDest = GetPortBitMapForCopyBits( myPort );	CopyBits( pSource, pDest, &captureRect, &drawRect, inkMode, 0);#endif}