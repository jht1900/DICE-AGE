// ===========================================================================//	CCaptureWind.cp	// ===========================================================================/* -- History:(c) 2003 John Henry Thompson. All rights reserved.2001.07.?? 	jht		Created.*/#include "CCaptureWind.h"#include "CShapeRect.h"#include "AETestDef.h"#include "CCapturePane.h"#include "ResDef.h"#include "ControlDef.h"extern const ResIDT	PPob_ControlWindow;extern LWindow* theControlWindow;extern LWindow* theWindow;//extern LWindow* theNoteWindow;// --------------------------------------------------------------------------------CCaptureWind::CCaptureWind(LStream *inStream)#ifdef KEEP_CAPTURE_WINDOW_ALIVE	: CPermWind(inStream)#else	: LWindow(inStream)#endif{}// --------------------------------------------------------------------------------CCaptureWind::~CCaptureWind(){	// nothing special		// Clear out global.	theWindow = 0;}// --------------------------------------------------------------------------------void CCaptureWind::FinishCreateSelf(){	theCapturePane = dynamic_cast <CCapturePane *>( FindPaneByID( kCapturePane ) );	SetUseSubModelList(true); // to hold the shapes	SetModelKind(cWindow);    // this object is a window	//UReanimator::LinkListenerToControls( this, theControlWindow, PPob_ControlWindow);	UReanimator::LinkListenerToBroadcasters( this, theControlWindow, PPob_ControlWindow);	if (theControlWindow)	{		/* Hookup edit field num by hand */		for (PaneIDT id = kPanelDiffTolerance; id <= kPanelFullDrawPeriod; id++) 		{			LBroadcaster*	theBroadcaster = dynamic_cast<LBroadcaster*> ( theControlWindow->FindPaneByID( id ) );			if (theBroadcaster != nil) 			{				theBroadcaster->AddListener(this);			}		}	}}// --------------------------------------------------------------------------------LModelObject*	CCaptureWind::HandleCreateElementEvent(									DescType			inElemClass,									DescType			inInsertPosition,									LModelObject*		inTargetObject,									const AppleEvent	&inAppleEvent,									AppleEvent			&outAEReply){	LModelObject	*result = nil;		switch (inElemClass) {		case cShapeRect:			result = new CShapeRect(this);			break;		default:			result = LWindow::HandleCreateElementEvent(					inElemClass,inInsertPosition,inTargetObject,inAppleEvent,outAEReply);		}		if (result) {		{			// add data (using pContents as the property)			StAEDescriptor	data;			data.GetOptionalParamDesc(inAppleEvent,keyAEData,typeWildCard);			if (data.mDesc.dataHandle) { // has a value				StAEDescriptor	ignore;				result->SetAEProperty(pContents,data,ignore);			}		}		{			// add properties by iterating through record and setting each one			StAEDescriptor props;			props.GetOptionalParamDesc(inAppleEvent,keyAEPropData,typeAERecord);			if (props.mDesc.dataHandle) { // has a value				OSErr	err;				long	max;				err = ::AECountItems(props,&max);				FailOSErr_(err);				for(long i = 1; i <= max; ++i) {					DescType		theKeyword;					StAEDescriptor	theValue,ignore;					err = ::AEGetNthDesc(props, i, typeWildCard, &theKeyword, theValue);					FailOSErr_(err);					result->SetAEProperty(theKeyword,theValue,ignore);				}						}		}		{			// adjust position in list			SInt32	currentPosition = mSubModels->FetchIndexOf(result);			SInt32	targetPosition = currentPosition;						switch (inInsertPosition) {				case kAEBeginning:					targetPosition = 1;					break;				case kAEEnd:					targetPosition = LArray::index_Last;					break;				case kAEBefore:				case kAEReplace:					targetPosition = mSubModels->FetchIndexOf(inTargetObject);					break;				case kAEAfter:					targetPosition = 1 + mSubModels->FetchIndexOf(inTargetObject);					break;			}			mSubModels->MoveItem(currentPosition, targetPosition);			if (inInsertPosition == kAEReplace)	delete inTargetObject;		}	}		return result;}// --------------------------------------------------------------------------------void			CCaptureWind::HandleSetDiffBackImage(const AppleEvent	&inAppleEvent,									AppleEvent			&outAEReply,									AEDesc				&outResult,									SInt32				inAENumber){	long			num = 1;		inAppleEvent;	outAEReply;	outResult;	inAENumber;		#if 0	{		long	count = 0;		long	index;        DescType               desiredType = typeWildCard;        AEKeyword             theAEKeyword;        DescType              typeCode;	        char	               dat[100];        Size                   maximumSize;        Size                  actualSize;				::AECountItems( &inAppleEvent, &count);		for (index = 1; index <= count; index++)		{			AEGetNthPtr( &inAppleEvent, index, desiredType, &theAEKeyword, &typeCode, &dat, sizeof(dat), &actualSize);		}	}		StAEDescriptor	data;		data.GetOptionalParamDesc(inAppleEvent, keyEffect, typeSInt32);		if (data.mDesc.dataHandle) 	{ // has a value		UExtractFromAEDesc::TheSInt32(data.mDesc, num);				SetEffectNum( num);	}	#endif		if (theCapturePane)	{		theCapturePane->SetDiffBackImage();	}}// --------------------------------------------------------------------------------void			CCaptureWind::SetEffectNum( SInt32 newEffectNum ){	if (theCapturePane)	{		theCapturePane->SetEffectNum( newEffectNum );	}}									// --------------------------------------------------------------------------------void			CCaptureWind::HandleAppleEvent(const AppleEvent	&inAppleEvent,									AppleEvent			&outAEReply,									AEDesc				&outResult,									SInt32				inAENumber){	switch (inAENumber) {		case ae_SetDiffBackImage:			HandleSetDiffBackImage(inAppleEvent, outAEReply, outResult, inAENumber);			break;		default:			LWindow::HandleAppleEvent(inAppleEvent, outAEReply, outResult, inAENumber);			break;	}}// --------------------------------------------------------------------------------void			CCaptureWind::GetAEProperty(DescType		inProperty,						 const AEDesc	&inRequestedType,						 AEDesc			&outPropertyDesc) const{	OSErr	err;	SInt32	num;	Rect	rect;		if (! theCapturePane)	{		goto other;	}		switch (inProperty) {			case pEffect:			num = theCapturePane->GetEffectNum();		setit: ;			err = ::AECreateDesc(typeSInt32, &num, sizeof(num), &outPropertyDesc);			FailOSErr_(err);			break;				case pDiffTolerance:			num = theCapturePane->GetDiffTolerance();			goto setit;			break;		case pMenuVisible:			num = theCapturePane->GetMeuVisible();			goto setit;			break;		case pStillFactor:			num = theCapturePane->GetStillFactor();			goto setit;			break;		case pCaptureScale:			num = theCapturePane->GetCaptureScale();			goto setit;			break;					#if 0		case pDrawScale:			num = theCapturePane->GetDrawScale();			goto setit;			break;		#endif				case pInk:			num = theCapturePane->GetInk();			goto setit;			break;		case pBlend:			num = theCapturePane->GetBlend();			goto setit;			break;		case pRect:			GetGlobalBounds(rect);		setRect:;			err = ::AECreateDesc(typeQDRectangle, &rect, sizeof(rect), &outPropertyDesc);			FailOSErr_(err);			break;		case pDrawRect:			theCapturePane->GetDrawRect(rect);			goto setRect;			break;					case pColorCycleNum:			num = theCapturePane->GetColorCycleNum();			goto setit;			break;		case pColorCycleCount:			num = theCapturePane->GetColorCycleCount();			goto setit;			break;		case pBackImage:			break;					case pBrushImage:			break;				case pInputDevice:			num = theCapturePane->GetInputDeviceNum();			goto setit;			break;#if 0		case pContents:			err = ::AECreateDesc(typeQDRectangle,&mBounds,sizeof(mBounds),&outPropertyDesc);			FailOSErr_(err);			break;		case pLineWidth:			err = ::AECreateDesc(typeShortInteger,&mLineWidth,sizeof(mLineWidth),&outPropertyDesc);			FailOSErr_(err);			break;#endif		default:		other:			LWindow::GetAEProperty(inProperty,inRequestedType,outPropertyDesc);			break;		}}// --------------------------------------------------------------------------------void			CCaptureWind::SetAEProperty(DescType		inProperty,						 const AEDesc	&inValue,						 AEDesc			&outAEReply){	SInt32 		num;	Rect		rect;	FSSpec					fss;	if (! theCapturePane)	{		goto other;	}	switch (inProperty) {		case pEffect:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetEffectNum( num);			break;					case pDiffTolerance:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetDiffTolerance( num);			break;					case pMenuVisible:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetMeuVisible( num);			break;					case pStillFactor:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetStillFactor( num);			break;					case pCaptureScale:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetCaptureScale( num);			break;				#if 0		case pDrawScale:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetDrawScale( num);			break;		#endif				case pInk:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetInk( num);			break;					case pBlend:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetBlend( num);			break;					case pRect:			UExtractFromAEDesc::TheRect(inValue, rect);			DoSetBounds( rect );			break;					case pDrawRect:			UExtractFromAEDesc::TheRect(inValue, rect);			theCapturePane->SetDrawRect( rect);			break;					case pColorCycleNum:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetColorCycleNum( num);			break;					case pColorCycleCount:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetColorCycleCount( num);			break;		case pBackImage:			UExtractFromAEDesc_TheFileSpec(inValue, fss);			theCapturePane->SetBackImage( fss);			break;					case pBrushImage:			UExtractFromAEDesc_TheFileSpec(inValue, fss);			theCapturePane->SetBrushImage( fss);			break;					case pInputDevice:			UExtractFromAEDesc::TheSInt32(inValue, num);			theCapturePane->SetInputDeviceNum( num);			break;		default:		other:;			LWindow::SetAEProperty(inProperty, inValue, outAEReply);			break;		}}// --------------------------------------------------------------------------------void	CCaptureWind::UExtractFromAEDesc_TheFileSpec(const AEDesc	&inDesc, FSSpec &fss ){	AEDesc	coerceDesc = {typeNull, nil};	if (::AECoerceDesc(&inDesc, typeFSS, &coerceDesc) == noErr) {		OSErr err = ::AEGetDescData(&coerceDesc, &fss, sizeof(FSSpec));		::AEDisposeDesc(&coerceDesc);		ThrowIfOSErr_(err);	} else {						// Coercion failed		ThrowOSErr_(errAETypeError);	}	#if 0	OSErr err = ::AEGetDescData(&inValue, &fss, sizeof(fss));	#endif}		// --------------------------------------------------------------------------------boolCCaptureWind::AEPropertyExists(	DescType	inProperty) const{	bool	exists = false;	switch (inProperty) {		case pEffect:		case pDiffTolerance:		case pMenuVisible:		case pStillFactor:		case pCaptureScale:		//case pDrawScale:		case pInk:		case pBlend:		case pRect:		case pDrawRect:		case pColorCycleNum:		case pColorCycleCount:		case pBackImage:		case pBrushImage:		case pInputDevice:			exists = true;			break;		default:			exists = LWindow::AEPropertyExists(inProperty);			break;	}	return exists;}// --------------------------------------------------------------------------------void			CCaptureWind::GetImportantAEProperties(AERecord &outRecord) const{	LWindow::GetImportantAEProperties(outRecord);#if 0	AEDesc	desiredType;	desiredType.descriptorType = typeWildCard;	{	//	filled			StAEDescriptor	aProp;			GetAEProperty(pFilled, desiredType, aProp);			UAEDesc::AddKeyDesc(&outRecord, pFilled, aProp);	}	{	//	line width			StAEDescriptor	aProp;			GetAEProperty(pLineWidth, desiredType, aProp);			UAEDesc::AddKeyDesc(&outRecord, pLineWidth, aProp);	}#endif}// --------------------------------------------------------------------------------void			CCaptureWind::DrawSelf(){	LWindow::DrawSelf();	#if 0	LArrayIterator	iter(*mSubModels);	LModelObject	*model;	while(iter.Next(&model)) {		if (cShapeRect == model->GetModelKind())			((CShapeRect *)model)->DrawSelf();	}	#endif	}// --------------------------------------------------------------------------------void			CCaptureWind::AddSubModel(LModelObject	*inSubModel){	LWindow::AddSubModel(inSubModel);	if (cShapeRect == inSubModel->GetModelKind())	{		Refresh();	}}// --------------------------------------------------------------------------------void			CCaptureWind::RemoveSubModel(LModelObject	*inSubModel){	LWindow::RemoveSubModel(inSubModel);	if (cShapeRect == inSubModel->GetModelKind())	{		Refresh();	}}// --------------------------------------------------------------------------------voidCCaptureWind::SyncOtherPane( int num, PaneIDT pid){	LEditField	*p = dynamic_cast<LEditField*>( theControlWindow->FindPaneByID( pid ) );	if (p)	{		p->SetValue( num );		p->Draw( 0 );	}	EventRecord Dummy = { 0 };	theCapturePane->SpendTime( Dummy );}// --------------------------------------------------------------------------------void	CCaptureWind::ListenToMessage(MessageT inMessage, void *ioParam){	int		num;		if (! theCapturePane)	{		return;	}		switch (inMessage)	{		case kSetSetMenuOn:			theCapturePane->SetMeuVisible( 1 );			break;		case kSetSetMenuOff:			theCapturePane->SetMeuVisible( 0 );			break;		case kSetInput1:			theCapturePane->SetInputDeviceNum( 1);			break;		case kSetInput2:			theCapturePane->SetInputDeviceNum( 2);			break;		case kSetEffectLoop:			num = *(SInt32*)ioParam;			theCapturePane->SetLoopEffects( num );			if (num)			{				theCapturePane->SetLoopEffectDuration( 30 );			}			break;		case kSetBoxesLoop:			num = *(SInt32*)ioParam;			theCapturePane->SetLoopBoxes( num );			if (num)			{				theCapturePane->SetLoopBoxesDuration( 1 * 60 );			}			break;		case kImageBox:			num = *(SInt32*)ioParam;			theCapturePane->SetImageBox( num );			break;					case kSetFullDraw:			theCapturePane->SetFullDraw();			{				LControl	*p = dynamic_cast<LControl*>( theControlWindow->FindPaneByID( kSetBoxesLoop ) );				if (p)				{					p->SetValue( 0 );				}			}			break;					case kSetLoopFullDraw:			theCapturePane->SetLoopFullDraw( *(SInt32*)ioParam );			break;					case kPanelLoopEffectPeriod:			theCapturePane->SetLoopEffectDuration( *(SInt32*)ioParam * 6 );			break;		case kArrowLoopEffectPeriod:			num = *(SInt32*)ioParam;			theCapturePane->SetLoopEffectDuration( num * 6 );			SyncOtherPane( num, kPanelLoopEffectPeriod);			break;					case kPanelLoopBoxPeriod:			theCapturePane->SetLoopBoxesDuration( *(SInt32*)ioParam * 6 );			break;		case kArrowLoopBoxPeriod:			num = *(SInt32*)ioParam;			theCapturePane->SetLoopBoxesDuration( num * 6 );			SyncOtherPane( num, kPanelLoopBoxPeriod);			break;					case kPanelDiffTolerance:			theCapturePane->SetDiffTolerance( *(SInt32*)ioParam );			break;		case kArrowDiffTolerance:			num = *(SInt32*)ioParam;			theCapturePane->SetDiffTolerance( num );			SyncOtherPane( num, kPanelDiffTolerance);			break;		case kPanelStillFactor:			theCapturePane->SetStillFactor( *(SInt32*)ioParam);			break;		case kArrowStillFactor:			num = *(SInt32*)ioParam;			theCapturePane->SetStillFactor( num );			SyncOtherPane( num, kPanelStillFactor);			break;					case kPanelBoxScale:			theCapturePane->SetBoxScale( *(SInt32*)ioParam );			break;		case kArrowBoxScale:			num = *(SInt32*)ioParam;			theCapturePane->SetBoxScale( num );			SyncOtherPane( num, kPanelBoxScale);			break;					case kPanelColorCyclePeriod:			theCapturePane->SetColorCycleCount( *(SInt32*)ioParam );			break;		case kArrowColorCyclePeriod:			num = *(SInt32*)ioParam;			theCapturePane->SetColorCycleCount( num );			SyncOtherPane( num, kPanelColorCyclePeriod);			break;		case kPanelFullDrawPeriod:			theCapturePane->SetLoopFullDrawPeriod( *(SInt32*)ioParam * 6 );			break;		case kArrowFullDrawPeriod:			num = *(SInt32*)ioParam;			theCapturePane->SetLoopFullDrawPeriod( num * 6 );			SyncOtherPane( num, kPanelFullDrawPeriod);			break;					case kPanelConvFactor:			theCapturePane->SetConvolutionFactor( *(SInt32*)ioParam );			break;		case kArrowConvFactor:			num = *(SInt32*)ioParam;			theCapturePane->SetConvolutionFactor( num );			SyncOtherPane( num, kPanelConvFactor);			break;					case kCaptureFull:			theCapturePane->SetCaptureScale( 1 );			break;		case kCaptureHalf:			theCapturePane->SetCaptureScale( 2 );			break;		case kCaptureQtr:			theCapturePane->SetCaptureScale( 4 );			break;		case kCapture8th:			theCapturePane->SetCaptureScale( 8 );			break;					case kPalettePopUp:			num = *(SInt32*)ioParam;			theCapturePane->SetPaletteNum( num );			break;					case kSetBackImageButton:			theCapturePane->SetDiffBackImage();			break;		case kPanelBackImagePeriod:			theCapturePane->SetBackImagePeriod( *(SInt32*)ioParam * 6 );			break;		case kArrowBackImagePeriod:			num = *(SInt32*)ioParam;			theCapturePane->SetBackImagePeriod( num*6 );			SyncOtherPane( num, kPanelBackImagePeriod);			break;		case kSetLoopBackImage:			theCapturePane->SetLoopBackImage( *(SInt32*)ioParam );			break;					case kDrawA:			theCapturePane->DrawLayer( "A", theCapturePane->drawRect );			break;					case kDrawB:			theCapturePane->DrawLayer( "B", theCapturePane->drawRect );			break;	}	if (inMessage >= kSetEffectMsg0 && inMessage <= kSetEffectMsgLast)	{		theCapturePane->SetEffectNum( inMessage - kSetEffectMsg0 );	}}// ---------------------------------------------------------------------------------Boolean		CCaptureWind::HandleKeyPress(const EventRecord	&inKeyEvent){	Boolean		result = FALSE;	char		buf[2];		buf[0] = (char)inKeyEvent.message;	buf[1] = 0;		theCapturePane->DrawLayer( buf, theCapturePane->boxWalkEffect->outRect );		return result;}// --------------------------------------------------------------------------------// --------------------------------------------------------------------------------