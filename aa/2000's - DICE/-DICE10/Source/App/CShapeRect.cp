// ===========================================================================//	CShapeRect.cp				©1995-2000 Metrowerks Inc. All rights reserved.// ===========================================================================#include "CShapeRect.h"#include "CCaptureWind.h"#include "AETestDef.h"CShapeRect::CShapeRect(CCaptureWind *inSuperModel)	: LModelObject(inSuperModel,cShapeRect),	 mFilled(false), mLineWidth(1), mRotateState(0){	::SetRect(&mBounds,0,0,0,0);}CShapeRect::~CShapeRect(){}void	CShapeRect::DrawSelf(){	// draw fill pattern	if (mFilled) {		Pattern	thePattern;		::GetIndPattern(&thePattern,sysPatListID,4);		::FillRect(&mBounds,&thePattern);	}	// draw frame	::PenSize(mLineWidth,mLineWidth);	::FrameRect(&mBounds);}void	CShapeRect::Refresh(){	// we know this cast is safe because the constructor	// requires the mSuperModel to be a CCaptureWind	CCaptureWind	*window = (CCaptureWind *)mSuperModel;	window->Refresh();}void	CShapeRect::Rotate(){	SInt16	width = mBounds.right - mBounds.left,			height = mBounds.bottom - mBounds.top;		switch (mRotateState++ % 4) {		case 0:			mBounds.left = mBounds.left - height;			break;		case 1:			mBounds.left = mBounds.right - height;			mBounds.top = mBounds.top - width;			break;		case 2:			mBounds.left = mBounds.right;			mBounds.top = mBounds.bottom - width;			break;		case 3:			mBounds.top = mBounds.bottom;			break;				}			mBounds.right = mBounds.left + height;	mBounds.bottom = mBounds.top + width;	Refresh();	}		void			CShapeRect::HandleAppleEvent(const AppleEvent	&inAppleEvent,									AppleEvent			&outAEReply,									AEDesc				&outResult,									SInt32				inAENumber){	switch (inAENumber) {		case ae_Rotate:			Rotate();			break;		default:			LModelObject::HandleAppleEvent(inAppleEvent,outAEReply, outResult,inAENumber);			break;	}}void			CShapeRect::GetAEProperty(DescType		inProperty,						 const AEDesc	&inRequestedType,						 AEDesc			&outPropertyDesc) const{	OSErr	err;	switch (inProperty) {		case pContents:			err = ::AECreateDesc(typeQDRectangle,&mBounds,sizeof(mBounds),&outPropertyDesc);			FailOSErr_(err);			break;		case pFilled:			err = ::AECreateDesc(typeBoolean,&mFilled,sizeof(mFilled),&outPropertyDesc);			FailOSErr_(err);			break;					case pLineWidth:			err = ::AECreateDesc(typeShortInteger,&mLineWidth,sizeof(mLineWidth),&outPropertyDesc);			FailOSErr_(err);			break;			default:			LModelObject::GetAEProperty(inProperty,inRequestedType,outPropertyDesc);			break;		}}void			CShapeRect::SetAEProperty(DescType		inProperty,						 const AEDesc	&inValue,						 AEDesc			&outAEReply){	switch (inProperty) {			case pContents:			UExtractFromAEDesc::TheRect(inValue,mBounds);			Refresh();			break;		case pFilled:			UExtractFromAEDesc::TheBoolean(inValue,mFilled);			Refresh();			break;					case pLineWidth:			UExtractFromAEDesc::TheSInt16(inValue,mLineWidth);			Refresh();			break;					default:			LModelObject::SetAEProperty(inProperty, inValue, outAEReply);			break;		}}void			CShapeRect::GetImportantAEProperties(AERecord &outRecord) const{	LModelObject::GetImportantAEProperties(outRecord);	AEDesc	desiredType;	desiredType.descriptorType = typeWildCard;	{	//	filled			StAEDescriptor	aProp;			GetAEProperty(pFilled, desiredType, aProp);			UAEDesc::AddKeyDesc(&outRecord, pFilled, aProp);	}	{	//	line width			StAEDescriptor	aProp;			GetAEProperty(pLineWidth, desiredType, aProp);			UAEDesc::AddKeyDesc(&outRecord, pLineWidth, aProp);	}}