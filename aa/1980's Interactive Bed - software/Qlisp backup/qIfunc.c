/**/#include "qDef.h"extern Env		*ev;extern qItem	trueSym;qItem icar(), icdr(), icadr(), icddr(), icaddr(), icdddr();qItem inullp(), ieq(), isetq(), iquote(), ifreec(), idefun();qItem itrace(), ifdef(), Mapcan(), Set(), ilist(), iif(), iprint();qItem Get(), Put(), iread(), iset(), iplist();qItem ConsCount(), Nth(), imod(), iadd(), isub(), imult(), idiv(); qItem iprog(), iand(), ior(), inot(), ilessp(), igreaterp(), ilistp();qItem ireturn(), SaveEnv(), iload(), Progn(), iwhile(), icaseq(), Gensym();qItem Mapatoms(), Apply(), irplaca(), irplacd(), inump();qItem FOpen(), FRead(), FPrint(), FClose(), FCreate(), FPutc();qIfunc qPrimIfunc[] =	{	{ Cons, "cons",  2,		"adds an element to a list" },	{ icar, "car", 1,		"the first element in the list" },	{ icdr, "cdr", 1,		"everything after the first element in the list" },	{ icadr, "cadr", 1,		"the second element in a list" },	{ icddr, "cddr", 1,		"everything after the second element in the list" },	{ icaddr, "caddr", 1,		"the third element in the list" },	{ icdddr, "cdddr", 1,		"everything after the third element in the list" },		{ inullp, "nullp", 1,		"t if a is nil" },	{ ieq, "eq", 2,		"t if both are identical" },	{ ieq, "=", 2,		"t if both are identical" },	{ isetq, "setq", 2 + qNoEval,		"assigns variable a the value b" },	{ iset, "set", 2,		"assigns b to the symbol a" },	{ iquote, "quote", 1 + qNoEval,		"prevents evaluation of a" },	{ ifreec, "freec", 0,		"the number of free cons cells" },	{ idefun, "defun", 0 + qNoEval,		"defines a function" },	{ Progn, "progn", 0 + qNoEval,		"evaluates all arguments, returns the last" },	{ itrace, "trace", 1 + qCint1,		"set trace level" },	{ ifdef, "fdef", 1,		"the function definition of symbol a"},	{ Eval, "eval", 1,		"evaluates a"  },	{ Mapcan, "mapcan", 2,		"applies function a to each element of list b, returns nil" },	{ ilist, "list", 0 + qNoEval,		"creates a list of its arguments" },	{ iif, "if", 3 + qNoEval,		"evaluates b if a is true, else evaluates c"},	{ iprint, "print", 1,		"writes a to the console" },	{ Get, "get", 2,		"the b property of symbol a"},	{ Put, "put", 3,		"gives symbol a the b property c" },	{ iread, "read", 1,		"the next expression from the console" },	{ iplist, "plist", 1,		"the property list of symbol a" },	{ ConsCount, "cons-count", 0,		"the number of cons cells" },	{ Length, "length", 1,		"the length of list a" },	{ Nth, "nth", 2,		"the a'th element of list b" },	{ imod, "mod", 2,		"a module b" },	{ iadd, "+", 2,		"sumation of a and b" },	{ isub, "-", 2,		"the difference between a and b" },	{ imult, "*", 2,		"the product of a and b" },	{ idiv, "/", 2,		"a divided by b" },			{ iwhile, "while", 0 + qNoEval,		"repeat the body while a is t" },	{ iprog, "prog", 0 + qNoEval,		"define a program with local variables" },	{ ireturn, "return", 1,		"return the result of a program" },	{ iand, "and", 0 + qNoEval,		"the first null value" },	{ ior, "or", 0 + qNoEval,		"the first non-null value" },	{ inot, "not", 1,		"the negation of a" },	{ ilessp, "<", 2,		"t if the number a is less than b" },	{ igreaterp, ">", 2,		"t is the number a is greater than b" },	{ ilistp, "listp", 1,		"t if a is a list" },	{ SaveEnv, "save", 1,		"saves the environment to file a" },	{ iload, "load", 1,		"loads the environment from file a" },	{ icaseq, "caseq", 0 + qNoEval,		"evaluates the first clause which is true" },	{ Gensym, "gensym", 0,		"the next unique symbol" },	{ Mapatoms, "mapatoms", 1,		"apply function a to all the known symbols" },	{ Apply, "apply", 2,		"call function a with the list of arguments b" },	{ Last, "last", 1,		"the last element of list a" },	{ irplaca, "rplaca", 2,		"replace the first element of list a with b" },	{ irplacd, "rplacd", 2,		"replace the rest of list a with b" },	{ inump, "nump", 1,		"t if a is a number" },	{ FOpen, "fopen", 1,		"open file a, return file object" },	{ FClose, "fclose", 1,		"close file object a" },	{ FRead, "fread", 1,		"the next expression from file object a" },	{ FPrint, "fprint", 2,		"write b to file object a" },	{ FCreate, "fcreate", 1,		"create a file whose name is a, return file object" },	{ FPutc, "fputc", 2,		"write character b to file object a" },		{ 0, 0, 0, 0}	};	static qItem	irplaca(lp, a)	register qList	*lp;	qItem			a;	{	if (! Listp(lp))		{		printf("Rplaca not list %lx\n",lp);		return (NIL);		}	Rplaca(lp, a);	return ((qItem) lp);	}	static qItem	irplacd(lp, a)	register qList	*lp;	qItem			a;	{	if (! Listp(lp))		{		printf("Rplacd not list %lx\n",lp);		return (NIL);		}	Rplacd(lp, a);	return ((qItem) lp);	}		static qItem	inump(x)	qItem	x;	{	if (Nump(x))		return (trueSym);	return (NIL);	}	static qItem	icaseq( al)	register qList	*al;	{	register qItem	sel, cas, tst;		if (! Listp(al))		{		printf("Bad case %lx\n", al);		return (NIL);		}			sel = Eval( Car(al));	for (al = Cdr(al); Listp(al); al = Cdr(al))		{		cas = Car(al);				if (! Listp(cas))			continue;					if (sel == Car(cas))			{			return (Progn( Cdr(cas)) );			}					if (trueSym == Car(cas))			{			return (Progn( Cdr(cas)) );			}		}	return (NIL);	}		static qItem	iload( sy)	qSymbol	*sy;	{	extern long	topleveljb[];	extern int	fdload;	int			er;		if (! Symbolp(sy))		{		printf("Load not a symbol %lx\n", sy);		return ((qItem) sy);		}			er = FSOpen(sy->name, 0, &fdload);	if (er)		{		printf("Load er=%d on %s\n", er, sy->name + 1);		return ((qItem) sy);		}		longjmp(topleveljb, 1);	}		static qItem	ilistp(al)	qItem	al;	{	if (Listp(al))		return (trueSym);	return (NIL);	}	/* -------------------------------------------------------------------- */#include <setjmp.h>static jmp_buf	progjb;static qItem	progval;static int		proglevel = 0;static qItem	iprog( al)	register qList	*al;	{	qItem			localVars;	jmp_buf			ojb;		if (! Listp(al))		return (NIL);			localVars = Car(al);	al = Cdr(al);		PushArgs( localVars, NIL);	proglevel += 1;	BlockMove(progjb, ojb, (long) sizeof(jmp_buf));			if (setjmp(progjb) == 0)		{		progval = Progn( al);		}		proglevel -= 1;	BlockMove(ojb, progjb, (long) sizeof(jmp_buf));	PopArgs( localVars);		return ( progval );	}	static qItem	ireturn( vl)	qItem	vl;	{	if (proglevel < 1)		{		printf("Return not in prog\n");		return (vl);		}			progval = vl;	longjmp(progjb, 1);	return (NIL);	}static qItem	iwhile( al)	register qList	*al;	{	qItem	test;	jmp_buf			ojb;		if (! Listp(al))		{		printf("Bad while\n");		return (NIL);		}			test = Car(al);	al = Cdr(al);		proglevel += 1;	BlockMove(progjb, ojb, (long) sizeof(jmp_buf));			if (setjmp(progjb) == 0)		{		for (;! Nullp(Eval( test));)			{			progval = Progn( al);			}		}		proglevel -= 1;	BlockMove(ojb, progjb, (long) sizeof(jmp_buf));	return(progval);	}	/* -------------------------------------------------------------------- */static qItem	ior( al)	register qList	*al;	{	register qItem	vl;		for (; Listp(al); al = Cdr(al))		{		vl = Eval( Car(al));		if (! Nullp(vl))			return (vl);		}	return (vl);	}	static qItem	iand( al)	register qList	*al;	{	register qItem	vl;		for (; Listp(al); al = Cdr(al))		{		vl = Eval( Car(al));		if (Nullp(vl))			return (vl);		}	return (vl);	}	static qItem	inot(a)	qItem	a;	{	if (Nullp(a))		return (trueSym);	return (NIL);	}static qItem	ilessp(a, b)	long	a, b;	{	if (Cnum(a) < Cnum(b))		return (trueSym);	return (NIL);	}static qItem	igreaterp(a, b)	long	a, b;	{	if (Cnum(a) > Cnum(b))		return (trueSym);	return (NIL);	}	static qItem	iplist(sym)	register qSymbol	*sym;	{	if (! Symbolp(sym))		{		printf("Plist not a symbol %lx\n", sym);		return (NIL);		}	return ((qItem) sym->plist);	}	static qItem	iread( sym)	register qSymbol	*sym;	{		if (! Symbolp(sym))		{		InitConsole(ev);		return (ReadConsole( "? "));		}			ReadFile( sym->name);		return ((qItem) sym);	}	static qItem	iprint( it)	qItem	it;	{	PrintConsole( it);	return (NIL);	}	static qItem	iif( al)	register qItem	al;	{		if (! Listp(al))		return (al);			if ( Nullp(Eval( Car(al))) )		{		return ( Eval( icaddr(al)) );		}			return ( Eval( icadr(al)) );	}	static qItem icdddr(x)	qItem	x;	{		x = icddr(x);		return (icdr(x));	}	static qItem icddr(x)	qList	*x;	{	if (! Listp(x))		return ((qItem) x);			x = Cdr(x);	if (! Listp(x))		return ((qItem) x);			return ((qItem) Cdr(x) );	}	static qItem	icadr(x)	qList	*x;	{	if (! Listp(x))		return ((qItem)x);			x = Cdr(x);	if (! Listp(x))		return ((qItem)x);			return (Car(x));	}	static qItem	icaddr(x)	qItem x;	{	x = icddr(x);	if (! Listp(x))		return (x);			return (Car(x));	}	static qItem	ilist( al)	register qList	*al;	{	register qList	*lp;		for (lp = (qList *)NIL; Listp(al); al = Cdr(al))		{		lp = Cons( Eval( Car(al)), lp);		}	lp = Nreverse(lp);	return ((qItem)lp);	}		static qItem	ifdef(sy)	qSymbol	*sy;	{	if (! Symbolp(sy))		return (NIL);		return (sy->func);	}	static qItem	itrace(x)	{	extern char	qtrace;		qtrace = x;		return (NIL);	}		static qItem	idefun( fdef)	qList			*fdef;	{	qSymbol			*sy;	qList			*rest;		if (! Listp(fdef))		return (NIL);			sy = (qSymbol *) Car(fdef);	if (! Symbolp(sy))		{		printf("defun not symbol sy=%lx\n", sy);		return (NIL);		}		sy->func = (qItem) Cdr(fdef);	return ((qItem) sy);	}		static qItem	ifreec()	{	return ( Length(ev->freeList) );	}	static qItem	icar(lp)	qList	*lp;	{		if (! Listp(lp))		return ((qItem) lp);			return (Car(lp));	}	static qItem	icdr(lp)	qList	*lp;	{		if (! Listp(lp))		return ((qItem) lp);			return ((qItem) Cdr(lp));	}	static qItem	inullp(it)	qItem	it;	{	if (Nullp(it))		return (trueSym);			return (NIL);	}	static qItem	ieq(a, b)	qItem	a;	qItem	b;	{	extern	qItem	trueSym;		if (a == b)		return (trueSym);	return (NIL);	}	static qItem	isetq( al)	qList	*al;	{	qSymbol	*sy;		if (! Listp(al))		return (NIL);			sy = (qSymbol *) Car(al);		if (! Symbolp(sy) || ! Listp(Cdr(al)) )		return (NIL);			sy->val = Eval( Cadr(al));	return ( sy->val );	}	static qItem	iset(sym, val)	register qSymbol	*sym;	qItem	val;	{	if (! Symbolp(sym))		{		printf("Set not symbol %lx\n", sym);		return (NIL);		}	sym->val = val;	return (val);	}	static qItem	iquote( al)	qList	*al;	{	if (! Listp(al))		return (NIL);			return ( Car(al) );	}	static qItem	imod(a, b)	long	a;	long	b;	{	return (Numify(a % b));	}	static qItem	iadd(a, b)	long	a;	long	b;	{	return (Numify(a + b));	}	static qItem	isub(a, b)	long	a;	long	b;	{	return (Numify(a - b));	}	static qItem	imult(a, b)	long	a;	long	b;	{	return (Numify(a * b));	}	static qItem	idiv(a, b)	long	a;	long	b;	{	return (Numify(a / b));	}	