/**/#include "qDef.h"extern qItem	trueSym;qItem icar(), icdr(), icadr(), icddr(), icaddr(), icdddr();qItem inullp(), ieq(), isetq(), iquote(), ifreec(), idefun();qItem itrace(), ifdef(), Mapcan(), Set(), ilist(), iif(), iprint();qItem Get(), Put(), iread(), iset(), iplist();qItem ConsCount(), Nth(), imod(), iadd(), isub(), imult(), idiv(); qItem iprog(), iand(), ior(), inot(), ilessp(), igreaterp(), ilistp();qItem ireturn(), SaveEnv(), iload(), Progn(), iwhile(), icaseq(), Gensym();qItem Mapatoms(), Apply(), irplaca(), irplacd(), inump();qItem FOpen(), FRead(), FPrint(), FClose(), FCreate(), FPutc();qIfunc qPrimIfunc[] =	{	{ Cons, "cons",  2 + qEnvArg },	{ icar, "car", 1 },	{ icdr, "cdr", 1 },	{ icadr, "cadr", 1 },	{ icddr, "cddr", 1 },	{ icaddr, "caddr", 1 },	{ icdddr, "cdddr", 1 },		{ inullp, "nullp", 1 },	{ ieq, "eq", 2 },	{ ieq, "=", 2 },	{ isetq, "setq", 2 + qNoEval + qEnvArg },	{ iset, "set", 2 },	{ iquote, "quote", 1 + qNoEval + qEnvArg },	{ ifreec, "freec", 0 + qEnvArg },	{ idefun, "defun", 0 + qNoEval + qEnvArg },	{ Progn, "progn", 0 + qNoEval + qEnvArg },	{ itrace, "trace", 1 + qCint1 },	{ ifdef, "fdef", 1 },	{ Eval, "eval", 1 + qEnvArg },	{ Mapcan, "mapcan", 2 + qEnvArg },	{ Set, "set", 2 },	{ ilist, "list", 1 + qNoEval + qEnvArg },	{ iif, "if", 3 + qNoEval + qEnvArg },	{ iprint, "print", 1 + qEnvArg },	{ Get, "get", 2 },	{ Put, "put", 3 + qEnvArg },	{ iread, "read", 1 + qEnvArg },	{ iplist, "plist", 1 },	{ ConsCount, "cons-count", 0 + qEnvArg },	{ Length, "length", 1 },	{ Nth, "nth", 2 },	{ imod, "mod", 2 },	{ iadd, "+", 2 },	{ isub, "-", 2 },	{ imult, "*", 2 },	{ idiv, "/", 2 },	{ iwhile, "while", 0 + qNoEval + qEnvArg  },	{ iprog, "prog", 0 + qNoEval + qEnvArg },	{ ireturn, "return", 1 + qEnvArg },	{ iand, "and", 0 + qNoEval + qEnvArg  },	{ ior, "or", 0 + qNoEval + qEnvArg },	{ inot, "not", 1 },	{ ilessp, "<", 2 },	{ igreaterp, ">", 2 },	{ ilistp, "listp", 1 },	{ SaveEnv, "save", 1 + qEnvArg },	{ iload, "load", 1 + qEnvArg },	{ icaseq, "caseq", 0 + qNoEval + qEnvArg },	{ Gensym, "gensym", 0 + qEnvArg },	{ Mapatoms, "mapatoms", 1 + qEnvArg },	{ Apply, "apply", 2 + qEnvArg },	{ Last, "last", 1 },	{ irplaca, "rplaca", 2 },	{ irplacd, "rplacd", 2 },	{ inump, "nump", 1 },	{ FOpen, "fopen", 1 + qEnvArg },	{ FClose, "fclose", 1 + qEnvArg },	{ FRead, "fread", 1 + qEnvArg },	{ FPrint, "fprint", 2 + qEnvArg },	{ FCreate, "fcreate", 1 + qEnvArg },	{ FPutc, "fputc", 2 + qEnvArg },		{ 0, 0, 0 }	};	static qItem	irplaca(lp, a)	register qList	*lp;	qItem			a;	{	if (! Listp(lp))		{		printf("Rplaca not list %lx\n",lp);		return (NIL);		}	Rplaca(lp, a);	return ((qItem) lp);	}	static qItem	irplacd(lp, a)	register qList	*lp;	qItem			a;	{	if (! Listp(lp))		{		printf("Rplacd not list %lx\n",lp);		return (NIL);		}	Rplacd(lp, a);	return ((qItem) lp);	}		static qItem	inump(x)	qItem	x;	{	if (Nump(x))		return (trueSym);	return (NIL);	}	static qItem	icaseq(ev, al)	Env				*ev;	register qList	*al;	{	register qItem	sel, cas, tst;		if (! Listp(al))		{		printf("Bad case %lx\n", al);		return (NIL);		}			sel = Eval(ev, Car(al));	for (al = Cdr(al); Listp(al); al = Cdr(al))		{		cas = Car(al);				if (! Listp(cas))			continue;					if (sel == Car(cas))			{			return (Progn(ev, Cdr(cas)) );			}					if (trueSym == Car(cas))			{			return (Progn(ev, Cdr(cas)) );			}		}	return (NIL);	}		static qItem	iload(ev, sy)	Env		*ev;	qSymbol	*sy;	{	extern long	topleveljb[];	extern int	fdload;	int			er;		if (! Symbolp(sy))		{		printf("Load not a symbol %lx\n", sy);		return ((qItem) sy);		}			er = FSOpen(sy->name, 0, &fdload);	if (er)		{		printf("Load er=%d on %s\n", er, sy->name + 1);		return ((qItem) sy);		}		longjmp(topleveljb, 1);	}		static qItem	ilistp(al)	qItem	al;	{	if (Listp(al))		return (trueSym);	return (NIL);	}	/* -------------------------------------------------------------------- */#include <setjmp.h>static jmp_buf	progjb;static qItem	progval;static int		proglevel = 0;static qItem	iprog(ev, al)	Env				*ev;	register qList	*al;	{	qItem			localVars;	jmp_buf			ojb;		if (! Listp(al))		return (NIL);			localVars = Car(al);	al = Cdr(al);		PushArgs(ev, localVars, NIL);	proglevel += 1;	BlockMove(progjb, ojb, (long) sizeof(jmp_buf));			if (setjmp(progjb) == 0)		{		progval = Progn(ev, al);		}		proglevel -= 1;	BlockMove(ojb, progjb, (long) sizeof(jmp_buf));	PopArgs(ev, localVars);		return ( progval );	}	static qItem	ireturn(ev, vl)	Env		*ev;	qItem	vl;	{	if (proglevel < 1)		{		printf("Return not in prog\n");		return (vl);		}			progval = vl;	longjmp(progjb, 1);	return (NIL);	}static qItem	iwhile(ev, al)	Env		*ev;	register qList	*al;	{	qItem	test;	jmp_buf			ojb;		if (! Listp(al))		{		printf("Bad while\n");		return (NIL);		}			test = Car(al);	al = Cdr(al);		proglevel += 1;	BlockMove(progjb, ojb, (long) sizeof(jmp_buf));			if (setjmp(progjb) == 0)		{		for (;! Nullp(Eval(ev, test));)			{			progval = Progn(ev, al);			}		}		proglevel -= 1;	BlockMove(ojb, progjb, (long) sizeof(jmp_buf));	return(progval);	}	/* -------------------------------------------------------------------- */static qItem	ior(ev, al)	Env				*ev;	register qList	*al;	{	register qItem	vl;		for (; Listp(al); al = Cdr(al))		{		vl = Eval(ev, Car(al));		if (! Nullp(vl))			return (vl);		}	return (vl);	}	static qItem	iand(ev, al)	Env				*ev;	register qList	*al;	{	register qItem	vl;		for (; Listp(al); al = Cdr(al))		{		vl = Eval(ev, Car(al));		if (Nullp(vl))			return (vl);		}	return (vl);	}	static qItem	inot(a)	qItem	a;	{	if (Nullp(a))		return (trueSym);	return (NIL);	}static qItem	ilessp(a, b)	long	a, b;	{	if (Cnum(a) < Cnum(b))		return (trueSym);	return (NIL);	}static qItem	igreaterp(a, b)	long	a, b;	{	if (Cnum(a) > Cnum(b))		return (trueSym);	return (NIL);	}	static qItem	iplist(sym)	register qSymbol	*sym;	{	if (! Symbolp(sym))		{		printf("Plist not a symbol %lx\n", sym);		return (NIL);		}	return ((qItem) sym->plist);	}	static qItem	iread(ev, sym)	Env					*ev;	register qSymbol	*sym;	{		if (! Symbolp(sym))		{		InitConsole(ev);		return (ReadConsole(ev, "? "));		}			ReadFile(ev, sym->name);		return ((qItem) sym);	}	static qItem	iprint(ev, it)	Env		*ev;	qItem	it;	{	PrintConsole(ev, it);	return (NIL);	}	static qItem	iif(ev, al)	Env				*ev;	register qItem	al;	{		if (! Listp(al))		return (al);			if ( Nullp(Eval(ev, Car(al))) )		{		return ( Eval(ev, icaddr(al)) );		}			return ( Eval(ev, icadr(al)) );	}	static qItem icdddr(x)	qItem	x;	{		x = icddr(x);		return (icdr(x));	}	static qItem icddr(x)	qList	*x;	{	if (! Listp(x))		return ((qItem) x);			x = Cdr(x);	if (! Listp(x))		return ((qItem) x);			return ((qItem) Cdr(x) );	}	static qItem	icadr(x)	qList	*x;	{	if (! Listp(x))		return ((qItem)x);			x = Cdr(x);	if (! Listp(x))		return ((qItem)x);			return (Car(x));	}	static qItem	icaddr(x)	qItem x;	{	x = icddr(x);	if (! Listp(x))		return (x);			return (Car(x));	}	static qItem	ilist(ev, al)	Env				*ev;	register qList	*al;	{	register qList	*lp;		for (lp = (qList *)NIL; Listp(al); al = Cdr(al))		{		lp = Cons(ev, Eval(ev, Car(al)), lp);		}	lp = Nreverse(lp);	return ((qItem)lp);	}		static qItem	ifdef(sy)	qSymbol	*sy;	{	if (! Symbolp(sy))		return (NIL);		return (sy->func);	}	static qItem	itrace(x)	{	extern char	qtrace;		qtrace = x;		return (NIL);	}		static qItem	idefun(ev, fdef)	Env				*ev;	qList			*fdef;	{	qSymbol			*sy;	qList			*rest;		if (! Listp(fdef))		return (NIL);			sy = (qSymbol *) Car(fdef);	if (! Symbolp(sy))		{		printf("defun not symbol sy=%lx\n", sy);		return (NIL);		}		sy->func = (qItem) Cdr(fdef);	return ((qItem) sy);	}		static qItem	ifreec(ev)	Env		*ev;	{	return ( Length(ev->freeList) );	}	static qItem	icar(lp)	qList	*lp;	{		if (! Listp(lp))		return ((qItem) lp);			return (Car(lp));	}	static qItem	icdr(lp)	qList	*lp;	{		if (! Listp(lp))		return ((qItem) lp);			return ((qItem) Cdr(lp));	}	static qItem	inullp(it)	qItem	it;	{	if (Nullp(it))		return (trueSym);			return (NIL);	}	static qItem	ieq(a, b)	qItem	a;	qItem	b;	{	extern	qItem	trueSym;		if (a == b)		return (trueSym);	return (NIL);	}	static qItem	isetq(ev, al)	Env		*ev;	qList	*al;	{	qSymbol	*sy;		if (! Listp(al))		return (NIL);			sy = (qSymbol *) Car(al);		if (! Symbolp(sy) || ! Listp(Cdr(al)) )		return (NIL);			sy->val = Eval(ev, Cadr(al));	return ( sy->val );	}	static qItem	iset(sym, val)	register qSymbol	*sym;	qItem	val;	{	if (! Symbolp(sym))		{		printf("Set not symbol %lx\n", sym);		return (NIL);		}	sym->val = val;	return (val);	}	static qItem	iquote(ev, al)	Env		*ev;	qList	*al;	{	if (! Listp(al))		return (NIL);			return ( Car(al) );	}	static qItem	imod(a, b)	long	a;	long	b;	{	return (Numify(a % b));	}	static qItem	iadd(a, b)	long	a;	long	b;	{	return (Numify(a + b));	}	static qItem	isub(a, b)	long	a;	long	b;	{	return (Numify(a - b));	}	static qItem	imult(a, b)	long	a;	long	b;	{	return (Numify(a * b));	}	static qItem	idiv(a, b)	long	a;	long	b;	{	return (Numify(a / b));	}	