/*	XCmdGlue.inc.c  Definitions for calling all standard 	HyperCard callback routines from C.  Include "HyperXCmd.h" 	before your program and this file after it.  Arguments are slightly 	different from Pascal.  The first argument is always a pointer to	the parameter block that HyperCard passed to the XCMD or XFCN.	This file derived from the Pascal interface, which is included as	comments.	  	©Apple Computer, Inc. 1987	All Rights Reserved.	See CFlash.C for an example of how to include this module in your 	C program.*//*  Do a simple jump subroutine to a procedure with no arguments.  The 	address of the procedure is in the argument.   Declared above in 	HyperXCmd.h.  *//*	typedef void (*MyProcPtr) ();  *//*  PROCEDURE DoJsr(addr: ProcPtr); INLINE $205F,$4E90;  */#include <MacTypes.h>#include <MemoryMgr.h>#include <ToolboxUtil.h>#include <QuickDraw.h>#include "HyperXCmd.h"pascal void SendCardMessage(paramPtr,msg)	XCmdBlockPtr	paramPtr;	StringPtr	msg;	/* Send a HyperCard message (a command with arguments) to the current card.	   msg is a pointer to a Pascal format string.  */{	paramPtr->inArgs[0] = (long)msg;	paramPtr->request = xreqSendCardMessage;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE SendCardMessage(msg: Str255);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@msg);      request := xreqSendCardMessage;      DoJsr(entryPoint);    END;END;   */pascal Handle EvalExpr(paramPtr,expr)	XCmdBlockPtr	paramPtr;	StringPtr	expr;	/* Evaluate a HyperCard expression and return the answer.  The answer is	   a handle to a zero-terminated string. */{	paramPtr->inArgs[0] = (long)expr;	paramPtr->request = xreqEvalExpr;    (* (MyProcPtr) (paramPtr->entryPoint))();	return (Handle)paramPtr->outArgs[0];}/*  FUNCTION EvalExpr(expr: Str255): Handle;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@expr);      request := xreqEvalExpr;      DoJsr(entryPoint);      EvalExpr := Handle(outArgs[1]);    END;END;   */pascal long StringLength(paramPtr,strPtr)	XCmdBlockPtr	paramPtr;	StringPtr	strPtr;/* Count the characters from where strPtr points until the next zero byte.    Does not count the zero itself.  strPtr must be a zero-terminated string. */{	paramPtr->inArgs[0] = (long)strPtr;	paramPtr->request = xreqStringLength;    (* (MyProcPtr) (paramPtr->entryPoint))();	return (long)paramPtr->outArgs[0];}/*	FUNCTION StringLength(strPtr: Ptr): LongInt;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(strPtr);      request := xreqStringLength;      DoJsr(entryPoint);      StringLength := outArgs[1];    END;END;   */pascal Ptr StringMatch(paramPtr,pattern,target)	XCmdBlockPtr	paramPtr;	StringPtr	pattern;	Ptr	target;/* Perform case-insensitive match looking for pattern anywhere in   target, returning a pointer to first character of the first match,   in target or NIL if no match found.  pattern is a Pascal string,   and target is a zero-terminated string. */{	paramPtr->inArgs[0] = (long)pattern;	paramPtr->inArgs[1] = (long)target;	paramPtr->request = xreqStringMatch;    (* (MyProcPtr) (paramPtr->entryPoint))();	return (Ptr)paramPtr->outArgs[0];}/*	FUNCTION StringMatch(pattern: Str255; target: Ptr): Ptr;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@pattern);      inArgs[2] := ORD(target);      request := xreqStringMatch;      DoJsr(entryPoint);      StringMatch := Ptr(outArgs[1]);    END;END;   */pascal void ZeroBytes(paramPtr,dstPtr,longCount)	XCmdBlockPtr	paramPtr;	Ptr	dstPtr;	long	longCount;/* Write zeros into memory starting at destPtr and going for longCount    number of bytes. */{	paramPtr->inArgs[0] = (long)dstPtr;	paramPtr->inArgs[1] = longCount;	paramPtr->request = xreqZeroBytes;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE ZeroBytes(dstPtr: Ptr; longCount: LongInt);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(dstPtr);      inArgs[2] := longCount;      request := xreqZeroBytes;      DoJsr(entryPoint);    END;END;   */pascal long StrToLong(paramPtr,strPtr)	XCmdBlockPtr	paramPtr;	Str31 *	strPtr;/* Convert a string of ASCII decimal digits to an unsigned long integer. */{	paramPtr->inArgs[0] = (long)strPtr;	paramPtr->request = xreqStrToLong;    (* (MyProcPtr) (paramPtr->entryPoint))();	return (long)paramPtr->outArgs[0];}/*	FUNCTION StrToLong(str: Str31): LongInt;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@str);      request := xreqStrToLong;      DoJsr(entryPoint);      StrToLong := outArgs[1];    END;END;   */pascal long StrToNum(paramPtr,str)	XCmdBlockPtr	paramPtr;	Str31 * 	str;/* Convert a string of ASCII decimal digits to a signed long integer.   Negative sign is allowed. */{	paramPtr->inArgs[0] = (long)str;	paramPtr->request = xreqStrToNum;    (* (MyProcPtr) (paramPtr->entryPoint))();	return paramPtr->outArgs[0];}/*	FUNCTION StrToNum(str: Str31): LongInt;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@str);      request := xreqStrToNum;      DoJsr(entryPoint);      StrToNum := outArgs[1];    END;END;  */pascal Boolean StrToBool(paramPtr,str)	XCmdBlockPtr	paramPtr;	Str31 * 	str;/* Convert the Pascal strings 'true' and 'false' to booleans. */{	paramPtr->inArgs[0] = (long)str;	paramPtr->request = xreqStrToBool;    (* (MyProcPtr) (paramPtr->entryPoint))();	return (Boolean)paramPtr->outArgs[0];}/*	FUNCTION StrToBool(str: Str31): BOOLEAN;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@str);      request := xreqStrToBool;      DoJsr(entryPoint);      StrToBool := BOOLEAN(outArgs[1]);    END;END;   */pascal void StrToExt(paramPtr,str,myext)	XCmdBlockPtr	paramPtr;	Str31 * 	str;	double *	myext; /* Convert a string of ASCII decimal digits to an extended long integer.	Instead of returning a new extended, as Pascal does, it expects you 	to create myext and pass it in to be filled. */{	paramPtr->inArgs[0] = (long)str;	paramPtr->inArgs[1] = (long)myext;	paramPtr->request = xreqStrToExt;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	FUNCTION StrToExt(str: Str31): Extended;VAR x: Extended;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@str);      inArgs[2] := ORD(@x);      request := xreqStrToExt;      DoJsr(entryPoint);      StrToExt := x;    END;END;   */pascal void LongToStr(paramPtr,posNum,mystr)	XCmdBlockPtr	paramPtr;	long 	posNum;	Str31 *	mystr; /* Convert an unsigned long integer to a Pascal string.  Instead of     returning a new string, as Pascal does, it expects you to 	create mystr and pass it in to be filled. */{	paramPtr->inArgs[0] = (long)posNum;	paramPtr->inArgs[1] = (long)mystr;	paramPtr->request = xreqLongToStr;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	FUNCTION LongToStr(posNum: LongInt): Str31;VAR str: Str31;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := posNum;      inArgs[2] := ORD(@str);      request := xreqLongToStr;      DoJsr(entryPoint);      LongToStr := str;    END;END;   */pascal void NumToStr(paramPtr,num,mystr)	XCmdBlockPtr	paramPtr;	long 	num;	Str31 *	mystr; /* Convert a signed long integer to a Pascal string.  Instead of     returning a new string, as Pascal does, it expects you to 	create mystr and pass it in to be filled. */{	paramPtr->inArgs[0] = num;	paramPtr->inArgs[1] = (long)mystr;	paramPtr->request = xreqNumToStr;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	FUNCTION NumToStr(num: LongInt): Str31;VAR str: Str31;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := num;      inArgs[2] := ORD(@str);      request := xreqNumToStr;      DoJsr(entryPoint);      NumToStr := str;    END;END;   */pascal void NumToHex(paramPtr,num,nDigits,mystr)	XCmdBlockPtr	paramPtr;	long 	num;	short	nDigits;			Str31 *	mystr;/* Convert an unsigned long integer to a hexadecimal number and put it   into a Pascal string.  Instead of returning a new string, as    Pascal does, it expects you to create mystr and pass it in to be filled. */{	paramPtr->inArgs[0] = num;	paramPtr->inArgs[1] = nDigits;	paramPtr->inArgs[2] = (long)mystr;	paramPtr->request = xreqNumToHex;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	FUNCTION NumToHex(num: LongInt; nDigits: INTEGER): Str31;VAR str: Str31;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := num;      inArgs[2] := nDigits;      inArgs[3] := ORD(@str);      request := xreqNumToHex;      DoJsr(entryPoint);      NumToHex := str;    END;END;   */pascal void BoolToStr(paramPtr,bool,mystr)	XCmdBlockPtr	paramPtr;	Boolean	bool;	Str31 *	mystr; /* Convert a boolean to 'true' or 'false'.  Instead of returning     a new string, as Pascal does, it expects you to create mystr	and pass it in to be filled. */{	paramPtr->inArgs[0] = (long)bool;	paramPtr->inArgs[1] = (long)mystr;	paramPtr->request = xreqBoolToStr;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	FUNCTION BoolToStr(bool: BOOLEAN): Str31;VAR str: Str31;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := LongInt(bool);      inArgs[2] := ORD(@str);      request := xreqBoolToStr;      DoJsr(entryPoint);      BoolToStr := str;    END;END;   */pascal void ExtToStr(paramPtr,myext,mystr)	XCmdBlockPtr	paramPtr;	double *	myext;	Str31 *	mystr; /* Convert an extended long integer to decimal digits in a string.      Instead of returning a new string, as Pascal does, it expects 	you to create mystr and pass it in to be filled. */{	paramPtr->inArgs[0] = (long)myext;	paramPtr->inArgs[1] = (long)mystr;	paramPtr->request = xreqExtToStr;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	FUNCTION ExtToStr(num: Extended): Str31;VAR str: Str31;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@num);      inArgs[2] := ORD(@str);      request := xreqExtToStr;      DoJsr(entryPoint);      ExtToStr := str;    END;END;   */pascal Handle GetGlobal(paramPtr,globName)	XCmdBlockPtr	paramPtr;	StringPtr	globName;/* Return a handle to a zero-terminated string containing the value of    the specified HyperTalk global variable. */{	paramPtr->inArgs[0] = (long)globName;	paramPtr->request = xreqGetGlobal;    (* (MyProcPtr) (paramPtr->entryPoint))();	return (Handle)paramPtr->outArgs[0];}/*	FUNCTION GetGlobal(globName: Str255): Handle;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@globName);      request := xreqGetGlobal;      DoJsr(entryPoint);      GetGlobal := Handle(outArgs[1]);    END;END;   */pascal void SetGlobal(paramPtr,globName,globValue)	XCmdBlockPtr	paramPtr;	StringPtr	globName;	Handle	globValue;/* Set the value of the specified HyperTalk global variable to be   the zero-terminated string in globValue.  The contents of the    Handle are copied, so you must still dispose it afterwards.  */{	paramPtr->inArgs[0] = (long)globName;	paramPtr->inArgs[1] = (long)globValue;	paramPtr->request = xreqSetGlobal;    (* (MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE SetGlobal(globName: Str255; globValue: Handle);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@globName);      inArgs[2] := ORD(globValue);      request := xreqSetGlobal;      DoJsr(entryPoint);    END;END;   */pascal Handle GetFieldByName(paramPtr,cardFieldFlag,fieldName)	XCmdBlockPtr	paramPtr;	Boolean	cardFieldFlag;	StringPtr	fieldName;/* Return a handle to a zero-terminated string containing the value of    field fieldName on the current card.  You must dispose the handle. */{	paramPtr->inArgs[0] = (long)cardFieldFlag;	paramPtr->inArgs[1] = (long)fieldName;	paramPtr->request = xreqGetFieldByName;    (* (MyProcPtr) (paramPtr->entryPoint))();	return (Handle)paramPtr->outArgs[0];}/*	FUNCTION GetFieldByName(cardFieldFlag: BOOLEAN; fieldName: Str255): Handle;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(cardFieldFlag);      inArgs[2] := ORD(@fieldName);      request := xreqGetFieldByName;      DoJsr(entryPoint);      GetFieldByName := Handle(outArgs[1]);    END;END;   */pascal Handle GetFieldByNum(paramPtr,cardFieldFlag,fieldNum)	XCmdBlockPtr	paramPtr;	Boolean	cardFieldFlag;	short	fieldNum;/* Return a handle to a zero-terminated string containing the value of    field fieldNum on the current card.  You must dispose the handle. */{	paramPtr->inArgs[0] = (long)cardFieldFlag;	paramPtr->inArgs[1] = fieldNum;	paramPtr->request = xreqGetFieldByNum;    (* (MyProcPtr) (paramPtr->entryPoint))();	return (Handle)paramPtr->outArgs[0];}/*	FUNCTION GetFieldByNum(cardFieldFlag: BOOLEAN; fieldNum: INTEGER): Handle;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(cardFieldFlag);      inArgs[2] := fieldNum;      request := xreqGetFieldByNum;      DoJsr(entryPoint);      GetFieldByNum := Handle(outArgs[1]);    END;END;   */pascal Handle GetFieldByID(paramPtr,cardFieldFlag,fieldID)	XCmdBlockPtr	paramPtr;	Boolean	cardFieldFlag;	short	fieldID;/* Return a handle to a zero-terminated string containing the value of    the field whise ID is fieldID.  You must dispose the handle. */{	paramPtr->inArgs[0] = (long)cardFieldFlag;	paramPtr->inArgs[1] = fieldID;	paramPtr->request = xreqGetFieldByID;    (*(MyProcPtr) (paramPtr->entryPoint))();	return (Handle)paramPtr->outArgs[0];}/*	FUNCTION GetFieldByID(cardFieldFlag: BOOLEAN; fieldID: INTEGER): Handle;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(cardFieldFlag);      inArgs[2] := fieldID;      request := xreqGetFieldByID;      DoJsr(entryPoint);      GetFieldByID := Handle(outArgs[1]);    END;END;   */pascal void SetFieldByName(paramPtr,cardFieldFlag,fieldName,fieldVal)	XCmdBlockPtr	paramPtr;	Boolean	cardFieldFlag;	StringPtr	fieldName;	Handle	fieldVal;/* Set the value of field fieldName to be the zero-terminated string    in fieldVal.  The contents of the Handle are copied, so you must    still dispose it afterwards. */{	paramPtr->inArgs[0] = (long)cardFieldFlag;	paramPtr->inArgs[1] = (long)fieldName;	paramPtr->inArgs[2] = (long)fieldVal;	paramPtr->request = xreqSetFieldByName;    (*(MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE SetFieldByName(cardFieldFlag: BOOLEAN; fieldName: Str255; fieldVal: Handle);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(cardFieldFlag);      inArgs[2] := ORD(@fieldName);      inArgs[3] := ORD(fieldVal);      request := xreqSetFieldByName;      DoJsr(entryPoint);    END;END;   */pascal void SetFieldByNum(paramPtr,cardFieldFlag,fieldNum,fieldVal)	XCmdBlockPtr	paramPtr;	Boolean	cardFieldFlag;	short	fieldNum;			Handle	fieldVal;/* Set the value of field fieldNum to be the zero-terminated string    in fieldVal.  The contents of the Handle are copied, so you must    still dispose it afterwards. */{	paramPtr->inArgs[0] = (long)cardFieldFlag;	paramPtr->inArgs[1] = fieldNum;	paramPtr->inArgs[2] = (long)fieldVal;	paramPtr->request = xreqSetFieldByNum;    (*(MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE SetFieldByNum(cardFieldFlag: BOOLEAN; fieldNum: INTEGER; fieldVal: Handle);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(cardFieldFlag);      inArgs[2] := fieldNum;      inArgs[3] := ORD(fieldVal);      request := xreqSetFieldByNum;      DoJsr(entryPoint);    END;END;   */pascal void SetFieldByID(paramPtr,cardFieldFlag,fieldID,fieldVal)	XCmdBlockPtr	paramPtr;	Boolean	cardFieldFlag;	short	fieldID;			Handle	fieldVal;/* Set the value of the field whose ID is fieldID to be the zero-   terminated string in fieldVal.  The contents of the Handle are    copied, so you must still dispose it afterwards. */{	paramPtr->inArgs[0] = (long)cardFieldFlag;	paramPtr->inArgs[1] = fieldID;	paramPtr->inArgs[2] = (long)fieldVal;	paramPtr->request = xreqSetFieldByID;    (*(MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE SetFieldByID(cardFieldFlag: BOOLEAN; fieldID: INTEGER; fieldVal: Handle);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(cardFieldFlag);      inArgs[2] := fieldID;      inArgs[3] := ORD(fieldVal);      request := xreqSetFieldByID;      DoJsr(entryPoint);    END;END;   */pascal Boolean StringEqual(paramPtr,str1,str2)	XCmdBlockPtr	paramPtr;	Str31 * 	str1;	Str31 * 	str2;/* Return true if the two strings have the same characters.     Case insensitive compare of the strings. */{	paramPtr->inArgs[0] = (long)str1;	paramPtr->inArgs[1] = (long)str2;	paramPtr->request = xreqStringEqual;    (*(MyProcPtr) (paramPtr->entryPoint))();	return (Boolean)paramPtr->outArgs[0];}/*	FUNCTION StringEqual(str1,str2: Str255): BOOLEAN;BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@str1);      inArgs[2] := ORD(@str2);      request := xreqStringEqual;      DoJsr(entryPoint);      StringEqual := BOOLEAN(outArgs[1]);    END;END;   */pascal void ReturnToPas(paramPtr,zeroStr,pasStr)	XCmdBlockPtr	paramPtr;	Ptr	zeroStr;	StringPtr	pasStr;/* zeroStr points into a zero-terminated string.  Collect the    characters from there to the next carriage Return and return    them in the Pascal string pasStr.  If a Return is not found,    collect chars until the end of the string. */{	paramPtr->inArgs[0] = (long)zeroStr;	paramPtr->inArgs[1] = (long)pasStr;	paramPtr->request = xreqReturnToPas;    (*(MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE ReturnToPas(zeroStr: Ptr; VAR pasStr: Str255);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(zeroStr);      inArgs[2] := ORD(@pasStr);      request := xreqReturnToPas;      DoJsr(entryPoint);    END;END;   */pascal void ScanToReturn(paramPtr,scanHndl)	XCmdBlockPtr	paramPtr;	Ptr *	scanHndl;/* Move the pointer scanPtr along a zero-terminated    string until it points at a Return character   or a zero byte.  */{	paramPtr->inArgs[0] = (long)scanHndl;	paramPtr->request = xreqScanToReturn;    (*(MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE ScanToReturn(VAR scanPtr: Ptr);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@scanPtr);      request := xreqScanToReturn;      DoJsr(entryPoint);    END;END;   */pascal void ScanToZero(paramPtr,scanHndl)	XCmdBlockPtr	paramPtr;	Ptr *	scanHndl;/* Move the pointer scanPtr along a zero-terminated    string until it points at a zero byte.  */{	paramPtr->inArgs[0] = (long)scanHndl;	paramPtr->request = xreqScanToZero;    (*(MyProcPtr) (paramPtr->entryPoint))();}/*	PROCEDURE ScanToZero(VAR scanPtr: Ptr);BEGIN  WITH paramPtr^ DO    BEGIN      inArgs[1] := ORD(@scanPtr);      request := xreqScanToZero;      DoJsr(entryPoint);    END;END;   */