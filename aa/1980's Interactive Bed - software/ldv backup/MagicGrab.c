/*Magic digitizer interface.*/#include <Quickdraw.h>#include <WindowMgr.h>#include "MagInfo.h"#include "Magic.h"MagInfo maginfo = 	{	2,		/* oddComp */	12,		/* stripOffset */	42,		/* nfields */	192,	/* nlines */	24,		/* startLine */	40,		/* High */	0,		/* low cutoff */	(Byte *)0xFA700	+ (40-1)*64 /* dest */	};#define MaxNlines	192#define MaxNfields	42#define MaxLine		(384)#define MaxRow		(64)#define MaxScreen	((long)MaxLine * (long)MaxRow)Byte	*dest1;		/* Destination for single grab */MagInit()	{	MagSccInit();	maginfo.bits.rowBytes = MaxRow;	SetRect(&maginfo.bits.bounds, 0, 0, MaxRow*8, MaxLine);	}/* Multi screen buffers */static Byte *bag = 0;static int	nbag = 0;/*Set up big buffer for multi grab.*/MagAlloc(n)	{	nbag = n;	if (bag) DisposPtr(bag);	bag = NewPtr( nbag * MaxScreen );	if (! bag)		{		fatal("\pNo memory for takes", "\p");		nbag = 0;		return (1);		}	return (0);	}	MagFree()	{	if (bag) DisposPtr(bag);	bag = 0L;	nbag = 0;	}	/*Grab nbag screen fulls into bag buffer.*/MagCapture()	{	int i;	Byte	*d = bag;	extern Cursor	waitCursor;	extern Cursor	arrowCursor;		SetCursor(&waitCursor);	for (i = 0; i < nbag; i++, d += MaxScreen)		{		maginfo.dest = d;		maginfo.bits.baseAddr = d;		MagGrab();		}	SetCursor(&arrowCursor);	}	MagCaptureOne(n)	{	Byte	*d = bag + n*MaxScreen;		SetCursor(&waitCursor);	maginfo.dest = d;	maginfo.bits.baseAddr = d;	MagGrab();	SetCursor(&arrowCursor);	}	MagGrab()	{	if (MagGrab1())		{		fatal("\pMAGIC Digitizer is not responding", 				"\pCheck video/serial cables");		}	}/*Display a screen in the bag*/MagToWin(win, rt, n)	WindowPtr	win;	Rect		*rt;	int			n;	{	maginfo.dest = bag + n*MaxScreen;	maginfo.bits.baseAddr = maginfo.dest;	MagCopyToScreen(win, rt);	}	MagShowAll(win, rt)	WindowPtr	win;	Rect		*rt;	{	int	i;		for (i = 0; i < nbag; i++)		{		MagToWin(win, rt, i);		}	}	static MagCopyToScreen(win, rect)	WindowPtr	win;	Rect		*rect;	{	Rect	r;	WindowPtr	owin;		GetPort(&owin);		if (owin != win)		SetPort(win);		MagSize(&r);		CopyBits(&maginfo.bits, &win->portBits, &r, rect, srcCopy, 0L);	if (owin != win)		SetPort(owin);	}MagSize(r)	Rect	*r;	{	r->top = 0;	r->left = 0;	r->right = maginfo.nfields*12;	r->bottom = maginfo.nlines*2;	}	#define HorLimit (28 + 42)#define VerLimit (70 + 192)MagStripOffset(n)	{	if (n < 1) n = 1;		if (n + maginfo.nfields > HorLimit)		n = HorLimit - maginfo.nfields;			maginfo.stripOffset = n;	return (n);	}	MagStartLine(n)	{	if (n + maginfo.nlines > VerLimit)		n = VerLimit - maginfo.nlines;		maginfo.startLine = n;	return (n);	}		MagNfields(n)	{	if (n > MaxNfields)		n = MaxNfields;	maginfo.nfields = n;	return (n);	}	MagNlines(n)	{	if (n > MaxNlines)		n = MaxNlines;	maginfo.nlines = n;	return (n);	}MagHigh(n)	{	maginfo.highCut = n&0xff;	return (n);	}	MagLow(n)	{	maginfo.lowCut = n&0xff;	return (n);	}	/* ------------------------------------------------------------------- *//*Honey dear, she called to me.We japanese do not have these honey words.Sing to me Sade's smooth operator.You never call. I know.*/#define SccRbase	0x9FFFF8#define SccWbase	0xBFFFF9#define aData		6#define aCtl		2#define bData		4#define bCtl		0#if 1Byte	INSCC[] = { 4, 4, 11, 0x28, 14, 0, 3, 0xC1, 5, 0x6A, 0x30, 0 };#define INSCClen	11#elseByte	INSCC[] = { 4, 4, 11, 0x28, 14, 0, 3, 0xC1, 5, 0x6A, 0x30, 15, 8, 0 };#define INSCClen	13#endifByte	*SWdata, *SWctl, *SRdata, *SRctl;MagPortA()	{	asm		{		lea		SWdata,a0		move.l	#SccWbase+aData,(a0)+		move.l	#SccWbase+aCtl,(a0)+		move.l	#SccRbase+aData,(a0)+		move.l	#SccRbase+aCtl,(a0)+		}	}	MagPortB()	{	asm		{		lea		SWdata,a0		move.l	#SccWbase+bData,(a0)+		move.l	#SccWbase+bCtl,(a0)+		move.l	#SccRbase+bData,(a0)+		move.l	#SccRbase+bCtl,(a0)+		}	}	MagSccInit()	{		asm		{		move.l	SWctl,a1		lea		INSCC,a0		moveq	#INSCClen-1,d0in1:	move.b	(a0)+,(a1)		dbf		d0, @in1		}	}	MagWrite1(ch)	{	register int 	to = 0x7FFF;	register Byte	*ctl = SRctl;		while (--to > 0 && !(*ctl & 0x04) );		if (to > 0)		{		*SWdata = ch;		return (1);		}	return (0);	}	MagRead1()	{	register int 	to = 0x7FFF;	register Byte	*ctl = SRctl;		while (--to > 0 && !(*ctl & 0x01) );		if (to > 0)		{		return ( *SRdata );		}		return (-1);	}	MagHreset()	{	asm		{		move	SR,-(sp)		ori		#0700,SR		;disable interrupts		move.l	SWctl,a0		move.b	#5,(a0)		move.b	#0x7A,(a0)	;send break		move.w	#17,d0	@1	dbf		d0,@1		move.b	#5,(a0)		;		move.b	#0x6A,(a0)	;remove break		move	(sp)+,SR		;enable interrupts again		}	}static MagGrab1(arg)	{	asm		{; TRANSFER A PICTURE INTO THE MAC for reading pictures whose  horz. size is ;				  not divisible by 3 i.e. 512 wide; reads in D3 fields at 3 bytes/swipe and then 1 more 8 bit swipe;; D1=COMP & odd/even FLAG	;D3= # OF FIELDS; D2=INITIAL STRIPE 		;D4= # OF LINES; D5= # of lines to delay down till picture starts; D6= High and Low Cut Value; A0= address to put data into	movem.l	a0-a6/d1-d7,-(sp)			MOVE	SR,-(SP)	ORI		#0x0700,SR		;KILL INTERRUPTS#if	DA#define	ax	a5#else#define	ax	a4#endif	move.w	maginfo.oddComp,d1	move.w	maginfo.stripOffset,d2	move.w	maginfo.nfields,d3	move.w	maginfo.nlines,d4	move.w	maginfo.startLine,d5	move.l	maginfo.highCut,d6	move.l	maginfo.dest,a0		move.w	d6,d0		;get low cut	jsr		@setlow	bne		@Gtmout1		swap	d6	move.w	d6,d0	jsr		@sethi		;set high cut	bne		@Gtmout1	lea		SWdata,a1	;get address of list of Scc addresses	move.l	(a1)+,ax		;get Scc Register Addresses	move.l	(a1)+,a3	move.l	(a1)+,a2	move.l	(a1)+,a1	/*ADD.w	MvHorVal(a5),d2	;center screen*/	MOVE.W	D4,D6		;GET # OF LINES/FIELD	ADD.W	D6,D6		;DOUBLE FOR LINES/FRAME	SUBQ.W	#1,D6		;LINES -1	MOVE.W	#-128,A6		;	LSL.W	#6,D6		;*64 = ADDRESS BACKUP AT BOTTOM  OF FRAME		move.b	(a2),d0		;	move.b	(a2),d0	move.b	(a2),d0	move.b	(a2),d0		;clean out SCC		MOVE.B	#0xA4,D0		;SEND PICTURE COMMAND	JSR		@OUTCHR	bne		@Gtmout		;timout error		MOVE.B	D2,D0		;INITIAL STRIPE 1	JSR		@OUTCHR	bne		@Gtmout		addq.w	#2,d3		;tell em 1 more for last 1 byte swipe	MOVE.B	D3,D0		;# OF FIELDS 2	JSR		@OUTCHR	bne		@Gtmout		subq.w	#2,d3		;	LSR.W	#1,D3		;MAKE FRAMES	SUBQ.W	#1,D3		;MAKE DBF D3,XXX VALUE	MOVE.B	D4,D0		;# OF LINES 3	JSR		@OUTCHR	bne		@Gtmout		move.b	d5,d0		;delay down 4	JSR		@OUTCHR	bne		@Gtmout		SUBQ.W #1,D4		;MAKE DBF COUNTERGETS1:	move.l	(sp),(sp)	;time delay	btst.b	#2,(a1)	beq		@GETS1		;	move.b	d1,(ax)		;send COMPLEMENT FLAG 5G0:		MOVE.W	#2-1,D0		;2 FIELDSG0A:		MOVE.W	D4,D2		;ONE FIELD LINE COUNTGOB:		move.w	#3-1,d7		;	move.l	#0x20000,d1	;timout constantG1:	subq.l	#1,d1		;count down timout	beq		@Gtmout		;timout		BTST.B	#0,(A1)		;CHAR READY?	BEQ		@G1			;NO		MOVE.B	(A2),(A0)+	;GET DATA BYTE	DBF		D7,@G1		ADDA	#128,A0		;SKIP A LINE	SUBA.W	#3,A0	DBF		D2,@GOB		;FOR 1 FIELD		SUBA.W	D6,A0		;BACKUP TO DO NEXT FIELD	DBF		D0,@G0A		;FOR FRAME		ADDA.W	A6,A0		;STEP OVER NUMBER OF BYTES WE TOOK	ADDA.W	#3,A0		; 	DBF		D3,@G0		;COUNT DOWN FRAMES	; now do last 1 byte swipe	GL0:	MOVE.W	#2-1,D0		;2 FIELDSGL0A:	MOVE.W	D4,D2		;ONE FIELD LINE COUNTGLOB:				move.l	#0x20000,d1	;timout constantGL1:		subq.l	#1,d1		;count down timout	beq		@Gtmout		;timout	BTST.B	#0,(A1)		;CHAR READY?	BEQ		@GL1			;NO		MOVE.B	(A2),(A0)+	;GET DATA BYTE	move.l	#0x20000,d1	;timout constantGL2:	subq.l	#1,d1		;count down timout	beq		@Gtmout		;timout	BTST.B	#0,(A1)		;CHAR READY?	BEQ		@GL2			;NO	MOVE.B	(A2),D5		;TAKE DATA BYTE BUT DON'T USE IT	move.l	#0x20000,d1	;timout constantGL3:	subq.l	#1,d1		;count down timout	beq		@Gtmout		;timout	BTST.B	#0,(A1)		;CHAR READY?	BEQ		@GL3			;NO	MOVE.B	(A2),D5		;TAKE DATA BYTE BUT IGNORE IT	ADDA.W	#128-1,A0	;SKIP A LINE	DBF		D2,@GLOB		;FOR 1 FIELD		SUBA.W	D6,A0		;BACKUP TO DO NEXT FIELD	DBF		D0,@GL0A		;FOR each Field		/* ----- all done ------- */		clr.w	d0		;no errorxreturn:	MOVE	(SP)+,SR	movem.l	(sp)+,a0-a6/d1-d7	return	Gtmout:Gtmout0:	_ShowCursor		;no	move.w	#1,d0		;timout error	goto	xreturn	Gtmout1:	bra		@Gtmout0;	set the high cut valuesethi:seth1:	swap	d0	move.b	#0xA0,d0	bra.s	@setl1	;	set the low cut valuesetlow:	swap	d0	move.b	#0xA2,d0	;command codesetl1:		jsr		@OUTCHR	bne		@setl2	swap	d0	jsr		@OUTCHRsetl2:	rts	OUTCHR:	move.l	SRctl,a1	move.l	SWdata,ax	move.w	d0,-(sp)	move.w	#0x8000,d0outc1:	subq.w	#1,d0		;timeout countdown	beq		@outcerr	btst.b	#2,(a1)	beq		@outc1		;	move.w	(sp)+,d0	move.b	d0,(ax)		;send char	move.l	d0,-(sp)		;	move.w	#50,d0outc2:	dbf		d0,@outc2		;wait for poor z-80	move.l	(sp)+,d0	ori		#0x4,CCR		;set zero flagoutc3:	rts	outcerr:	move.w	(sp)+,d0outc4:	andi	#0x0FB,CCR		;set non-zero	rts		}	}		