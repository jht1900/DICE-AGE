/**/#include <stdio.h>#include "qDef.h"#include "Stream.h"extern char qtrace;#define TRACE(a,b) if (qtrace >= a) printf b#define qFileSubType 'FILE'extern qItem	novalueSym;int StreamAlert(), ReadConsole1(), PrintConsole1();static Stream consoleStream =	{	qFileSubType,	StreamAlert, ReadConsole1, PrintConsole1, 	NIL, '\n'	};	#define ConsoleBufSize	128static Byte consoleBuf[ConsoleBufSize];void	InitConsole(ev)	Env	*ev;	{	register Stream	*s = &consoleStream;		s->eofId = novalueSym;	s->eofChar = 0;	s->bufMax = ConsoleBufSize;	s->bufPos = s->bufMax;	s->nread = s->bufMax;	s->buf = consoleBuf;	}static char *conMsg = "> ";qItem ReadConsole(ev, msg)	Env		*ev;	char	*msg;	{	conMsg = msg;		return (ReadStream(ev, &consoleStream));	}	static	ReadConsole1(s)	register Stream	*s;	{	printf(conMsg);	gets(s->buf);	s->bufPos = 0;	s->nread = strlen(s->buf) + 1;	s->bufMax = s->nread;	}	PrintConsole(ev, p)	Env		*ev;	qItem	p;	{	InitConsole(ev);	PrintStream(ev, &consoleStream, p);	printf("\n");	}	static PrintConsole1(s, str, len)	Stream	*s;	Byte	*str;	int		len;	{	printf("%s", str);	}	static	StreamAlert(a, b, c, d, e, f, g, h)	int		a;	long	b, c, d, e, f, g, h;	{	printf(b, c, d, e, f, g, h);	if (a) exit(0);	}	/* --------------------------------------------------------------------- */int StreamAlert(), ReadFile1(), PrintFile1();static Stream inputStream =	{	qFileSubType,	StreamAlert, ReadFile1, PrintFile1, 	NIL, -1	};	#define fileBufSize 512static Byte	fileBuf[fileBufSize];qItem	ReadFile(ev, fn)	Env				*ev;	Byte			*fn;	/* Pascal name */	{	register Stream	*s = &inputStream;	int				er;	qItem			it = NIL;		s->eofId = novalueSym;	s->eofChar = '\r';	s->bufMax = fileBufSize;	s->bufPos = s->bufMax;	s->nread = s->bufMax;	s->buf = fileBuf;	er = FSOpen(fn, 0, &s->fd);	if (er) 		{		StreamAlert(0, "Can't open %s er=%d\n", fn+1, er);		return (NIL);		}			for (;;)		{		it = ReadStream(ev, s);		if (! Listp(it))			break;		it = Eval(ev, it);		}			FSClose(s->fd);		return (it);	}	static	ReadFile1(s)	register Stream	*s;	{	int				er;	long			count = s->bufMax;		er = FSRead(s->fd, &count, s->buf);	if (er && er != -39 /*eofErr*/) StreamAlert(1, "Read error er=%d\n", er);	s->bufPos = 0;	s->nread = count;	}	static	PrintFile1(s, str, len)	register Stream	*s;	Byte			*str;	int				len;	{	if (s->bufPos + len > s->bufMax)		FlushStream(s);		s->needFlush = 1;		BlockMove(str, s->buf + s->bufPos, (long) len);		s->bufPos += len;	}	FlushStream(s)	Stream	*s;	{	int				er;	long			count = s->bufPos;		TRACE(0,("FlushStream: s=%lx count=%ld\n",s,count));		er = FSWrite(s->fd, &count, s->buf);	if (er) StreamAlert(1, "Write error er=%d\n", er);		s->bufPos = 0;	}	/* -------------------------------------------------------------------- */qItem	FOpen(ev, fn)	Env		*ev;	qSymbol	*fn;	{	Stream	*s;	int		er;	Stream	*initStream();		s = initStream(fn);	if (! s) 		return (NIL);			er = FSOpen(fn->name, 0, &s->fd);	if (er) 		{		StreamAlert(0, "Can't open %s er=%d\n", fn->name+1, er);		return (Numify(er));		}					return ( (qItem)s );	}	qItem	FCreate(ev, fn)	Env		*ev;	qSymbol	*fn;	{	Stream	*s;	int		er;	Stream	*initStream();		s = initStream(fn);	if (! s) 		return (NIL);			s->bufPos = 0;		er = FSDelete(fn->name, 0);		er = Create(fn->name, 0, '????', 'TEXT');	if (er) 		{		StreamAlert(0, "Can't create %s er=%d\n", fn->name+1, er);		return (Numify(er));		}			er = FSOpen(fn->name, 0, &s->fd);	if (er) 		{		StreamAlert(0, "Can't open %s er=%d\n", fn->name+1, er);		return (Numify(er));		}						return ( (qItem)s );	}		Stream	*initStream(fn)	qSymbol	*fn;	{	register Stream	*s;		if (! Symbolp(fn))		{		StreamAlert(0,"FOpen: not symbol %lx\n", fn);		return (NULL);		}			s = NewPtr((long) sizeof(Stream) + fileBufSize);	if (! s)		{		StreamAlert(0,"FOpen: malloc failed\n");		return (NULL);		}	s->type = qFileSubType;	s->alertf = StreamAlert;	s->readf = ReadFile1;	s->writef = PrintFile1;	s->eofId = NIL;	s->fd = -1;	s->eofId = novalueSym;	s->eofChar = '\r';	s->bufMax = fileBufSize;	s->bufPos = s->bufMax;	s->nread = s->bufMax;	s->needFlush = 0;	s->buf = (Byte *)(s+1);		s = (Stream *) qPtr(s, qIstructType);		return (s);	}	qItem	FRead(ev, s)	Env		*ev;	Stream	*s;	{	TRACE(1,("FRead: ev=%lx s=%lx\n",ev,s));		if (Type(s) != qIstructType || s->type != qFileSubType)		{		StreamAlert(0,"FRead: not file %lx\n",s);		return (NIL);		}			return ( ReadStream(ev, s) );	}qItem	FPrint(ev, s, it)	Env		*ev;	Stream	*s;	qItem	it;	{	TRACE(1,("FPrint: ev=%lx s=%lx\n",ev,s));		if (Type(s) != qIstructType || s->type != qFileSubType)		{		StreamAlert(0,"FPrint: not file %lx\n",s);		return (NIL);		}			PrintStream(ev, s, it);		return (NIL);	}qItem	FPutc(ev, s, ch)	Env		*ev;	Stream	*s;	qItem	ch;	{	TRACE(1,("FPutc: ev=%lx s=%lx\n",ev,s));		if (Type(s) != qIstructType || s->type != qFileSubType)		{		StreamAlert(0,"FPutc: not file %lx\n",s);		return (NIL);		}			if (s->bufPos + 1 > s->bufMax)		FlushStream(s);		s->needFlush = 1;		s->buf[s->bufPos] = ch;		s->bufPos += 1;		return (ch);	}		qItem	FClose(ev, s)	Env		*ev;	Stream	*s;	{	int		er;		TRACE(1,("FClose: ev=%lx s=%lx\n",ev,s));		if (Type(s) != qIstructType || s->type != qFileSubType)		{		StreamAlert(0,"FClose: not file %lx\n",s);		return (NIL);		}			if (s->needFlush)		FlushStream(s);			er = FSClose(s->fd);		s->type = 0;	DisposPtr(s);		return (Numify(er));	}			