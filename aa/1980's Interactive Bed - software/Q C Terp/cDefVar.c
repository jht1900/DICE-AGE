/**/#include "cGlob.h"/* --------------------------------------------------------------------- */extern cEnv			ce;/* --------------------------------------------------------------------- */#define stype(n, unsgn, siz, type) \	SimpleTypeEnt n = { SimpleTypeType, type, siz, unsgn }stype(stypeVoid,				0, 0, voidType);stype(stypeChar, 				0, 1, intType);stype(stypeUnsignedChar, 		1, 1, intType);stype(stypeShortInt, 			0, 2, intType);stype(stypeUnsignedShortInt, 	1, 2, intType);stype(stypeLongInt, 			0, 4, intType);stype(stypeUnsignedLongInt, 	1, 4, intType);stype(stypeFloat, 				0, 4, floatType);stype(stypeShortDouble, 		0, 8, floatType);stype(stypeDouble, 				0, 10, floatType);stype(stypeDefaultInt, 			0, DefaultIntSize, intType);stype(stypeDefaultUnsignedInt, 	1, DefaultIntSize, intType);PtrTypeEnt	stypeString = { PtrTypeType, (TypeEnt *)&stypeChar };/* --------------------------------------------------------------------- */cGetVarDefList(td)	TypeDeclArg		*td;	{	Ent				*tok;		TRACE(1,("cGetVarDefList: td=%lx\n", td));		/* We have the first variable def, get any others */		cGetVarInitAndDefine(td);	for (;;) 		{		tok = cGetToken();		switch (TermType(tok))			{			case semicolonTerm:				return;				break;			case commaTerm:					/* uses td->baseType to form type of variable, fills						in id and type */				cGetDecl(td);				cGetVarInitAndDefine(td);				break;			default:				cSyntaxError();				break;			}		}	}	/* --------------------------------------------------------------------- *//* Check for optional init following variable before defining it */cGetVarInitAndDefine(td)	TypeDeclArg		*td;	{	Ent				*tok;	Ent				*init = NULL;	/* should be be zero const ? */	Ent				*cGetConst();		TRACE(1,("cGetVarInitAndDefine: td=%lx\n", td));		tok = cGetToken();	if (TermType(tok) == equalTerm)		{			/* Need to handle structure init */		init = cGetConst();		}	else		{		cUngetToken(tok);		}			cDefineVar(td, init);	}/* --------------------------------------------------------------------- *//* Get storeage class and basetype. storage already set to default */cGetStorageBaseType(td)	TypeDeclArg		*td;	{	Ent				*tok;	Ent				*cGetBaseType();		TRACE(1,("cGetTypeDecl: td=%lx\n",td));		/* setup defaults */	td->lang = cLang;	td->id = NULL;	td->baseType = NULL;	td->type = NULL;		tok = cGetToken();		/* Determine storage class */	if (IsTerm(tok)			&& tok->termEnt.class == storageClass)		{		td->storage = autoStore + tok->termEnt.type - autoKey;		tok = cGetToken();		}			/* Check for pascal language */	if (TermType(tok) == pascalKey)		{		td->lang = pascalLang;		}	else		{		cUngetToken(tok);		}			td->baseType = cGetBaseType();	}	/* --------------------------------------------------------------------- */Ent	*cGetBaseType()	{	Ent				*tok;	Ent				*d;		Ent				*cGetStructDef();	Ent				*cGetUnionDef();	Ent				*cGetEnumDef();		TRACE(1,("cGetBaseType\n"));		tok = cGetToken();	switch (TermType(tok))		{		case structKey:			return ( cGetStructDef() );			break;					case unionKey:			return ( cGetUnionDef() );			break;					case enumKey:			return ( cGetEnumDef() );			break;					case intKey:			return ( (Ent *) &stypeDefaultInt );			break;					case charKey:			return ( (Ent *) &stypeChar );			break;				case doubleKey:			return ( (Ent *) &stypeDouble );			break;				case floatKey:			return ( (Ent *) &stypeFloat );			break;					case voidKey:			return ( (Ent *) &stypeVoid );			break;					case shortKey:			/* Check for int or double */			tok = cGetToken();			switch (TermType(tok))				{				case doubleKey:					return ( (Ent *) &stypeShortDouble );					break;				case intKey:					return ( (Ent *) &stypeShortInt );					break;				default:					cUngetToken(tok);					return ( (Ent *) &stypeShortInt );					break;				}			break;				case longKey:			/* Check for int or float */			tok = cGetToken();			switch (TermType(tok))				{				case floatKey:					return ( (Ent *) &stypeDouble );					break;				case intKey:					return ( (Ent *) &stypeLongInt );					break;				default:					cUngetToken(tok);					return ( (Ent *) &stypeLongInt );					break;				}			break;				case unsignedKey:			/* Check for long, short, int or char */			tok = cGetToken();			switch (TermType(tok))				{				case longKey:					tok = cGetToken();					if (TermType(tok) != intKey)						{						cUngetToken(tok);						}					return ( (Ent *) &stypeUnsignedLongInt );					break;									case shortKey:					tok = cGetToken();					if (TermType(tok) != intKey)						{						cUngetToken(tok);						}					return ( (Ent *) &stypeUnsignedShortInt );					break;									case intKey:					return ( (Ent *) &stypeDefaultUnsignedInt );					break;									case charKey:					return ( (Ent *) &stypeUnsignedChar );					break;									default:					cUngetToken(tok);					return ( (Ent *) &stypeDefaultUnsignedInt );					break;				}			break;					default:			/* Check for typedef name */			if (tok->tabEnt.et == IdEntType				&& (d = tok->idEnt.def) 				&& d->tabEnt.et == TypedefDefType)				{				return (d->typedefDef.type);				}			cUngetToken(tok);			return ( (Ent *) &stypeDefaultInt );			break;		}	}/* --------------------------------------------------------------------- */typedef struct RefQue	{	PtrTypeEnt	*firstRef;	PtrTypeEnt	*lastRef;	}	RefQue;static RefQue	refq;static Ent		*idSeen;static int		allowNullId;cList *cGetProtoArgList();/* --------------------------------------------------------------------- *//* Get declaration of a variable. Fills in id, and type, uses baseType */cGetDecl(td)	TypeDeclArg		*td;	{	TRACE(1,("cGetDecl: td=%lx\n",td));		allowNullId = td->allowNullId;		refq.firstRef = refq.lastRef = NULL;	idSeen = NULL;		cGetDecl2();		cAddRef(td->baseType);		td->type = (TypeEnt *) refq.firstRef;	td->id = idSeen;	}/* --------------------------------------------------------------------- *//* Get declaration of a variable, internal version */static cGetDecl2()	{	Ent		*tok, *t2;	short	p;		TRACE(1,("cGetDecl\n"));		/* Check for any pre-ops and id */	tok = cGetToken();	switch (TermType(tok))		{		case asteriskTerm:			/* Ptr operation */			cGetDecl2();			cAddPtr();			return;			break;					case lparenTerm:			/* Nested decl or func decl of abstract declation */			if (allowNullId)				{				t2 = cGetToken();				p = cIsTypeSpec(t2);				cUngetToken(t2);				if (p)					{					cUngetToken(tok);					/* Will be pickup in post op analysis as abstract func decl */					}				else					{					goto L1; /* Parse as nested decl */					}				}			else {L1:				/* Parse as nested decl */				cGetDecl2();				cDemand(rparenTerm);				}			/* Fall thru to pick up any post ops */			break;				default:			/* Check for id */			if (tok->tabEnt.et == IdEntType)				{				idSeen = tok;				}			else {				if (allowNullId)					{					cUngetToken(tok);					}				else {					cSyntaxError();					}				}			break;			}		/* Collect any post ops. Array or func ops */	for ( ;;) 		{		tok = cGetToken();		switch (TermType(tok))			{			case lparenTerm:				/* Function decl */				t2 = cGetToken();				if (TermType(t2) == rparenTerm)					{					/* func w/o arg def */					cAddFuncRef(NULL);					}				else if (cIsTypeSpec(t2))					{					/* func w/ arg def */					cUngetToken(t2);					cAddFuncRef(cGetProtoArgList());					}				else {					/* Unknow func arg, exit. Probable arg of function definition */					/* Put back both left paren and last token */					cUngetToken(t2);					cUngetToken(tok); 					return;					}				break;						case lsquareTerm:				/* Array op */				/* Check for null array dimension */				t2 = cGetToken();				if (TermType(t2) == rsquareTerm)					{					cAddArrayRef(0L);					}				else					{					cUngetToken(t2);					cAddArrayRef(cGetIntConst());					cDemand(rsquareTerm);					}				break;							default:				cUngetToken(tok);				return;				break;			}		}	}/* --------------------------------------------------------------------- *//* Add a deref operation to the type reference list */static cAddPtr()	{	PtrTypeEnt	*de;		TRACE(1,("cAddPtr\n"));		de = cNewObj(PtrTypeEnt);	de->et = PtrTypeType;	cAddRef(de);	}/* --------------------------------------------------------------------- *//* Add func ref op to type ref list */static cAddFuncRef(argList)	cList			*argList;	{	FuncTypeEnt		*fe;		TRACE(1,("cAddFuncRef\n: argList=%lx\n", argList));		/* Func can only be applied to de-ref or base type */	if (refq.lastRef && refq.lastRef->et != PtrTypeType)		cParseError("invalid function");			fe = cNewObj(FuncTypeEnt);	fe->et = FuncTypeType;	fe->argList = argList;	cAddRef(fe);	}	/* --------------------------------------------------------------------- *//* Add array ref op to type ref list */static cAddArrayRef(dim)	long			dim;	{	ArrayTypeEnt	*ae;		TRACE(1,("cAddArrayRef: dim=%ld\n",dim));		/* Can't have array of functions */	if (refq.lastRef && refq.lastRef->et == FuncTypeType)		cParseError("invalid array");			ae = cNewObj(ArrayTypeEnt);	ae->et = ArrayTypeType;	ae->dim = dim;	cAddRef(ae);	}	/* --------------------------------------------------------------------- *//* Add a generic op to type reference list.NOTE: may be use on simple types to so to field may not be valid */static cAddRef(xe)	PtrTypeEnt	*xe;	{	TRACE(1,("cAddRef: xe=%lx lastRef=%lx\n",xe,refq.lastRef));		if (refq.lastRef)		{		refq.lastRef->to = xe;		}	else		{		refq.firstRef = xe;		}	refq.lastRef = xe;	}/* --------------------------------------------------------------------- *//* true if tok is type-spec term, '...', or typedef name */static short cIsTypeSpec(tok)	Ent			*tok;	{	Ent			*d;		if (IsTerm(tok) 		&& (tok->termEnt.class == typeClass 			|| tok->termEnt.type == ellipsisTerm))		{		return (1);		}			if (tok->tabEnt.et == IdEntType		&& (d = tok->idEnt.def) 		&& d->tabEnt.et == TypedefDefType)		{		return (1);		}			return (0);	}/* --------------------------------------------------------------------- */cDemand(tt)	short		tt;	{	Ent			*tok;		TRACE(1,("cDemand: tt=%d\n", tt));		tok = cGetToken();	if (TermType(tok) != tt)		cSyntaxError();	}	/* --------------------------------------------------------------------- */Ent		*cGetAggreDef();Ent		*cGetAggreDecl();Ent		*cLookup();/* --------------------------------------------------------------------- */static Ent *cGetStructDef()	{	return (cGetAggreDef(StructEntType));	}/* --------------------------------------------------------------------- */static Ent *cGetUnionDef()	{	return (cGetAggreDef(UnionEntType));	}	/* --------------------------------------------------------------------- *//* Get declaration and/or definition of struct/union */static Ent *cGetAggreDef(et)	short			et;	{	Ent				*tok;	Ent				*id;	Ent				*def;	AggreTypeEnt	*ae;		TRACE(1,("cGetAggreDef: et=%d\n", et));		/* Look for id and/or decl-list */	tok = cGetToken();	if (TermType(tok) == lcurlyTerm)		{		/* Anonynmous struct decl */		ae = cNewObj(AggreTypeEnt);		ae->et = et;		ae->name = NULL;		ae->memList = NULL;		ae->size = 0;		return (cGetAggreDecl(et, ae));		}	else if (tok->tabEnt.et == IdEntType)		{		/* We've got an id, check for def */		id = tok;		tok = cGetToken();		if (TermType(tok) != lcurlyTerm)			{			/* not a def, find old definition */			cUngetToken(tok);			return ( cLookup(id, et) );			}		/* left curly bracket found, get definition */		return ( cGetAggreDecl(et, cLookup(id, et)) );		}	cSyntaxError();	}/* --------------------------------------------------------------------- *//* Get a declaration list */static Ent	*cGetAggreDecl(et, ae)	short			et;	AggreTypeEnt	*ae;	{	Que				q;	long			offset = 0;	long			maxSiz = 0;	long			siz;	short			fieldWidth;	TypeDeclArg		td;	AggreMember		*am, *ams;	Ent				*tok;	short			wordSize, preWordSize;	short			bitsTot = 0;		TRACE(1,("cGetAggreDecl: et=%d ae=%lx\n", et, ae));		if (ae->memList)		cParseError("redeclaration of struct/union");	cQueInit(&q);				td.baseType = cGetBaseType();	if (td.baseType->simpleType.et == SimpleTypeType)		wordSize = cTypeSize(td.baseType);	else wordSize = 0;	preWordSize = wordSize;		for (;;)		{		/* Check for padding field width */		fieldWidth = -1;		tok = cGetToken();		if (TermType(tok) == colonTerm)			{			td.id = NULL;			td.type = NULL;			fieldWidth = cGetIntConst();			}		else			{			cUngetToken(tok);			cGetDecl(&td);			/* Check for field width */			tok = cGetToken();			if (TermType(tok) == colonTerm)				{				fieldWidth = cGetIntConst();				}			else				{				cUngetToken(tok);				}			}		if (et != StructEntType && fieldWidth >= 0)			cParseError("field width not allowed in union");				/* Align on appropriate boundary */		if (fieldWidth < 0)			{			/* No field width. Make sure on appropriate boundary for its type */			/* Close out old field */			if (bitsTot > 0) offset += preWordSize;			bitsTot = 0;			/* Align to minimum boundary */			/* wordSize may be zero here if we don't have simple base type */			if (wordSize <= 0 || wordSize  > StructBoundary)				wordSize = StructBoundary;							offset += offset % wordSize;			}		else if (fieldWidth == 0)			{			/* Align on this guys boundary */			/* Zero field width valid only by itself */			if (td.id != NULL)				cParseError("invalid field width");			/* Close out old field */			if (bitsTot > 0) offset += preWordSize;			bitsTot = 0;				offset += offset % wordSize;			}		else {			/* We have a field. make sure can fit in current word */			/* Different word size also closes previous field */			if (fieldWidth > MaxIntSize * BitsPerChar)				cParseError("field width too big");			if (td.type && 				(td.type->tabEnt.et != SimpleTypeType 				|| td.type->simpleType.type != intType) )				cParseError("field width only valid for integer");			if (bitsTot + fieldWidth > preWordSize * BitsPerChar				|| preWordSize != wordSize)				{				offset += preWordSize;				offset += (offset % wordSize);				bitsTot = 0;				}			bitsTot += fieldWidth;			}		if (td.id == NULL)			goto next;					/* Make sure member id is not duplicate */		for (ams = (AggreMember *)q.first; ams; ams = ams->next)			{			if (ams->nameId == td.id)				cParseError("duplicate member name");			}					/* Allocate new member */		am = cNewObj(AggreMember);		am->nameId = td.id;		am->type = td.type;		am->offset = offset;		am->fieldWidth = fieldWidth;		am->bitOffset = bitsTot - fieldWidth;				if (fieldWidth < 0) siz = cTypeSize(td.type);		else siz = 0;				if (et == StructEntType) offset += siz;		else if (siz > maxSiz) maxSiz = siz;					cQueAdd(&q, (QueEnt *) am);				tok = cGetToken();		/* Check for new id of same basetype, new base type, or done */next:		preWordSize = wordSize;		switch (TermType(tok))			{			case commaTerm:				/* fall thru to collect more of same base type */				break;							case semicolonTerm:				/* Check for end or new base type */				tok = cGetToken();				if (TermType(tok) == rcurlyTerm)					{					/* Finish */					/* Close out any open field */					if (bitsTot > 0) offset += wordSize;					offset += offset % StructBoundary;					if (et == StructEntType) ae->size = offset;					else ae->size = maxSiz;										ae->memList = (AggreMember *) q.first;					return (ae);					}				cUngetToken(tok);				td.baseType = cGetBaseType();				if (td.baseType->simpleType.et == SimpleTypeType)					wordSize = cTypeSize(td.baseType);				else wordSize = 0;				break;							default:				cSyntaxError();			}		}	}	/* --------------------------------------------------------------------- *//* Look for aggre by id and et, if not found init to null */static Ent	*cLookup(id, et)	Ent			*id;	short		et;	{	AggreTypeEnt	*ae;	short			new;		TRACE(1,("cLookup: id=%lx et=%d\n",id,et));		ae = (AggreTypeEnt *)cInternByEt(				ce.auxTab, et, id, sizeof(AggreTypeEnt), &new);	if (new)		{		ae->memList = NULL;		ae->size = 0;		}			return (ae);	}	/* --------------------------------------------------------------------- *//* Get enum declaration and/or definition, return its type */static Ent	*cGetEnumDef()	{	Ent			*id;	Ent			*tok;	Ent			*cGetEnumDecl();	short		new;		TRACE(1,("cGetEnumDef:\n"));		tok = cGetToken();	if (TermType(tok) == lcurlyTerm)		{		/* Anonymous enum list */		return (cGetEnumDecl(NULL));		}	else if (tok->tabEnt.et == IdEntType)		{		/* We Have a name */		id = tok;		tok = cGetToken();		if (TermType(tok) == lcurlyTerm)			{			/* Define a new enum */			return (cGetEnumDecl(id));			}		else {			/* Not a definition look up old value */			cUngetToken(tok);			tok = cInternByEt(ce.auxTab, EnumEntType, id, 0, &new);			if (! tok)				cParseError("undefined enum type");			return (tok->enumEnt.type);			}		}	cSyntaxError();	}/* --------------------------------------------------------------------- *//* Define enum constants and return type that'll hold max value */static Ent *cGetEnumDecl(id)	Ent			*id;	{	long			seq = 0;	long			maxSeq = 0;	cList			*idList = NULL;	cList			*cl;	short			new;	EnumEnt			*ee;	TypeEnt			*type;	Ent				*tok;		TRACE(1,("cGetEnumDef: id=%lx\n"));		if (id)		{		/* Define a new enum type */		ee = (EnumEnt *) cInternByEt(ce.auxTab, EnumEntType, id, sizeof(EnumEnt), &new);		if (! new)			cParseError("enum already defined");		ee->type = NULL; /* Will be filled in later */		}	else {		/* Define an anonymous enum type */		ee = NULL;		}		/* Scan for members and define them */	for (;;)		{		tok = cGetToken();		if (tok->tabEnt.et != IdEntType)			cSyntaxError();					id = tok;		/* Check for resequencing */		tok = cGetToken();		if (TermType(tok) == equalTerm)			{			seq = cGetIntConst();			tok = cGetToken();			}					/* Define this enum const */		if (id->idEnt.def)			cParseError("enum already defined");				/* Use def to old sequence for this enum member */		id->idEnt.def = (Ent *) seq;		seq += 1;		if (seq > maxSeq) maxSeq = seq;				/* Add to list of members, this is a temporary list */		cl = cNewObj(cList);		cl->next = idList;		cl->ent = id;		idList = cl;				/* Check for end of decl */		switch (TermType(tok))			{			case commaTerm:				/* Fall thru to continue */				break;							case rcurlyTerm:				/* Exiting */				/* Determine max type */				if (maxSeq > MaxShort || maxSeq < MinShort) type = &stypeLongInt;				else if (maxSeq > MaxChar || maxSeq < MinChar) type = &stypeShortInt;				else type = &stypeChar;					/* Go back and set appropriate const type for members */				for (cl = idList; cl; cl = cl->next)					{					id = cl->ent;					switch (type->simpleType.size)						{						case 1:							id->idEnt.def = cMakeCharConst((char) id->idEnt.def);							break;						case 2:							id->idEnt.def = cMakeShortConst((short) id->idEnt.def);							break;						case 4:							id->idEnt.def = cMakeLongConst((long) id->idEnt.def);							break;						}					}									/* idList can now be reclaimed */								if (ee) ee->type = type;				return (type);				break;							default:				cSyntaxError();				break;			}		}	}	/* --------------------------------------------------------------------- *//* Initialize que */cQueInit(q)	Que		*q;	{	q->first = q->last = NULL;	}	/* --------------------------------------------------------------------- *//* Add and entry to the end of a que */cQueAdd(q, ent)	Que		*q;	QueEnt	*ent;	{	if (q->last)		{		q->last->next = ent;		}	else {		q->first = ent;		}	q->last = ent;	ent->next = NULL;	}	/* --------------------------------------------------------------------- *//* Collect type-decl args for prototype func definition */static cList *cGetProtoArgList()	{	return (NULL);	}	/* --------------------------------------------------------------------- *//* Gives variable type and initializer */cDefineVar(td, init)	TypeDeclArg	*td;	Ent			*init;	{	VarDefEnt	*df;		TRACE(1,("cDefineVar: td=%lx td->type=%lx init=%lx\n",td,td->type,init));		/* Check that old def and new one are compatiable */	df = td->id->def;	if (df)		{		cParseError("redeclaration of variable");		}			/* Setup new definition */		df = cNewObj(VarDefEnt);	df->et = VarDefType;	df->type = td->type;	df->storage = td->storage;	/* Should not allow pascal variables */	df->def = init;		td->id->def = df;	}/* --------------------------------------------------------------------- *//* Get and integer constant */long cGetIntConst()	{	Ent			*tok;	Ent			*type;		tok = cGetToken();	if (tok->tabEnt.et == ConstEntType		&& (type = tok->constEnt.type)->tabEnt.et == SimpleTypeType		&& type->simpleType.type == intType)		{		switch (type->simpleType.size)			{			case 1:				return ( * (char *) tok->constEnt.name );				break;			case 2:				return ( * (short *) tok->constEnt.name );				break;			case 4:				return ( * (long *) tok->constEnt.name );				break;			}		}	cParseError("Integer constant expected");	}	/* --------------------------------------------------------------------- *//* Return the size of the given type */long cTypeSize(type)	TypeEnt		*type;	{	switch (type->tabEnt.et)		{		case SimpleTypeType:			return (type->simpleType.size);			break;				case StructEntType:		case UnionEntType:			return (type->aggreType.size);			break;					case PtrTypeType:			return (PointerSize);			break;					case ArrayTypeType:			break;		}			cFatalError("cTypeSize of unknown type");	return (0);	}	/* --------------------------------------------------------------------- *//* Get a constant expression */Ent	*cGetConst()	{	return (cGetToken());	}/* --------------------------------------------------------------------- */