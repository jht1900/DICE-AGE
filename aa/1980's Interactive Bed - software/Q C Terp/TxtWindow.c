/*Text Windowing operations.11/11/87 John Thompson.*/#include <EventMgr.h>#include "TxtObj.h"#include "Obj.h"#include "qDef.h"/* --------------------------------------------------------------------- */#define TRACE(a,b) if (a < 0) printf bextern TxtObj	*me;extern qList	*windowList;#define SBarWidth	15/* --------------- TxtNew ---------------------------------------------- */long TxtNew(rt, title)	Rect	*rt;	Byte	*title;	{	Rect		destRect, viewRect;	Rect		vScrollRect;	FontInfo	myInfo;	int			height;	Byte		*SureAlloc();	extern long	(*TxtObjTable[])();		TRACE(2,("TxtNew:\n"));		me = (TxtObj *) SureAlloc( (long) sizeof(TxtObj) );		me->obj = TxtObjTable;		me->myWindow = NewWindow(0L, rt, title, TRUE, documentProc,						-1L, TRUE, 0L);	if (! me->myWindow) FatalError("\pNewWindow failed", "\pTxtWindow");		SetPort(me->myWindow);	TextFont(4);	TextSize(9);	vScrollRect = (*me->myWindow).portRect;	vScrollRect.left = vScrollRect.right-15;	vScrollRect.right += 1;	vScrollRect.bottom -= 14;	vScrollRect.top -= 1;	me->vScroll = NewControl( me->myWindow, &vScrollRect, "\p", 1, 0, 0, 0,		scrollBarProc, 0L);	viewRect = (*thePort).portRect;	viewRect.right -= SBarWidth;	viewRect.bottom -= SBarWidth;	destRect = viewRect;	InsetRect( &destRect, 4, 0 );	GetFontInfo( &myInfo );	height = myInfo.ascent+myInfo.descent+myInfo.leading;	me->linesInFolder = 		(viewRect.bottom-viewRect.top)/height;	viewRect.bottom = me->linesInFolder*height;		me->TEH = TENew( &destRect, &viewRect );	(*me->TEH)->crOnly = -1;		me->expStart = 0;		SetPt( &me->theOrigin, 0, 0 );	me->dirty = 0;	SetUpFiles();		windowList = Cons( qPtr(me, qIstructType) , windowList);	}/* --------------------- TxtDelete ------------------------------------ */static long TxtDelete()	{	}	/* --------------------------------------------------------------------- *//* -------------------- TxtDrag ---------------------------------------- */static long TxtDrag(ev)	EventRecord		*ev;	{	}/* -------------------------- TxtGrow ---------------------------------- */long TxtUpdate();static long TxtGrow( p )	Point p;	{		WindowPtr w = me->myWindow;	GrafPtr	savePort;	Rect	oldRect, tempRect;	long	theResult;	Point	thePt;	Rect 	r;		TRACE(2,("TxtGrow: %d %d\n",p.h,p.v));		GetPort( &savePort );	SetPort( w );	oldRect = (*w).portRect;	SetRect(&tempRect, 80, 80, screenBits.bounds.right, 			screenBits.bounds.bottom);	theResult = GrowWindow( w, p, &tempRect );	thePt.h = LoWord( theResult );	thePt.v = HiWord( theResult );	SizeWindow( w, thePt.h, thePt.v, 1 );	InvalRect( &(*w).portRect );	MoveControl( me->vScroll, (*w).portRect.right-SBarWidth, 		(*w).portRect.top-1);	SizeControl( me->vScroll, SBarWidth+1, 		(*w).portRect.bottom-(*w).portRect.top-(SBarWidth-2));	(**me->TEH).viewRect = (*w).portRect;	(**me->TEH).viewRect.right -= SBarWidth+1;	(**me->TEH).viewRect.bottom -= SBarWidth+1;	(**me->TEH).destRect.right = (**me->TEH).viewRect.right;	me->linesInFolder = 		((**me->TEH).viewRect.bottom-(**me->TEH).viewRect.top)/(**me->TEH).lineHeight;	(**me->TEH).viewRect.bottom = (**me->TEH).viewRect.top + 				(**me->TEH).lineHeight*me->linesInFolder;	EraseRect(&(*w).portRect);	r = (*w).portRect;	r.top = r.bottom - (SBarWidth+1);	InvalRect(&r);	TECalText( me->TEH );	TxtUpdate();	SetPort( savePort );	}/* ----------------------------- TxtContent ---------------------------- */static int	scrollCode;static int scrollAmt;pascal void ScrollProc();static long TxtContent( ev )	EventRecord		*ev;	{	WindowPtr		theWindow = me->myWindow;	int				cntlCode;	ControlHandle 	theControl;	int				pageSize;	GrafPtr			savePort;		TRACE(2,("TxtContent: ev=%lx\n", ev));		GetPort(&savePort);	SetPort(theWindow);	GlobalToLocal(&ev->where);	switch ( cntlCode = FindControl( ev->where, theWindow, &theControl ) ) 		{	case inUpButton:	case inDownButton:	case inPageUp:	case inPageDown:		if (theControl==me->vScroll) 			{			pageSize = ((**me->TEH).viewRect.bottom-(**me->TEH).viewRect.top) / 					(**me->TEH).lineHeight - 1;			switch (cntlCode) 				{				case inUpButton: 					scrollAmt = -1;					break;				case inDownButton: 					scrollAmt = 1;					break;				case inPageUp: 					scrollAmt = -pageSize;					break;				case inPageDown: 					scrollAmt = pageSize;					break;				}			scrollCode = cntlCode;			if (TrackControl(theControl, ev->where, &ScrollProc)) ;			}		break;	case inThumb:		if (TrackControl(theControl, ev->where, 0L )) ;		TxtUpdate();		break;	default:		if (PtInRect( ev->where, &(**me->TEH).viewRect ))			TEClick( ev->where,				((ev->modifiers & shiftKey )!=0), me->TEH);		}	SetPort(savePort);	}/* --------------------------- TxtKey_Down ----------------------------- */static long TxtKey_Down(theChar)	{	TRACE(2,("TxtKey_Down: %d\n", theChar));	TEKey( theChar, me->TEH );	TxtShowSelect();	me->dirty = 1;	}	/* ------------------------- TxtActivate ------------------------------- */static long TxtActivate(ev)	EventRecord		*ev;	{	Rect			r;		TRACE(2,("TxtActivate: ev=%lx\n", ev));	r = me->myWindow->portRect;	r.top = r.bottom - (SBarWidth+1);	r.left = r.left - (SBarWidth+1);	InvalRect(&r);	if ( ev->modifiers & activeFlag ) 		{		TEActivate( me->TEH );		ShowControl( me->vScroll );#if 0		DisableItem( myMenus[editM], undoCommand );#endif		TEFromScrap();		}	else 		{		TEDeactivate( me->TEH );		HideControl( me->vScroll );		ZeroScrap();		TEToScrap();		}	}	/* ---------------------- TxtUpdate ----------------------------------- */long TxtUpdate()	{		WindowPtr	theWindow = me->myWindow;	GrafPtr		savePort;	Rect		rt;		rt = (**me->TEH).viewRect;		TRACE(2,("TxtUpdate:\n"));		GetPort( &savePort );	SetPort( theWindow );	SetVScroll(me->TEH);	ScrollBits(theWindow);	BeginUpdate( theWindow );	DrawGrowIcon( theWindow );	TEUpdate( &rt, me->TEH );	DrawControls( theWindow );	EndUpdate( theWindow );	SetPort( savePort );	}	/* --------------------- TxtClose -------------------------------------- */static long TxtClose()	{	}/* --------------------- TxtIdle ---------------------------------------- */static long TxtIdle()	{	TEIdle( me->TEH );	}	/* --------------------------------------------------------------------- */static long TxtUndo()	{	}	static long TxtCut()	{	TECut( me->TEH );	me->dirty = 1;	}	static long TxtCopy()	{	TECopy( me->TEH );	}	static long TxtPaste()	{	TEPaste( me->TEH );	me->dirty = 1;	}static long TxtClear()	{	TEDelete( me->TEH );	me->dirty = 1;	}/* --------------------------------------------------------------------- */static long TxtPrint()	{	}	/* --------------------------------------------------------------------- */	CloseMyWindow()	{	HideWindow( me->myWindow );	TESetSelect( 0, (**me->TEH).teLength, me->TEH );	TEDelete( me->TEH );	SetVScroll();	SetUpFiles();	}SetUpFiles()	{	me->theFileName[0] = 0;	me->theVRefNum = 0;	}static ScrollBits(theWindow)	WindowPtr	theWindow;	{	Point		oldOrigin;	RgnHandle	tmpRgn;	int			dv;		oldOrigin = me->theOrigin;	me->theOrigin.v = (**me->TEH).lineHeight*GetCtlValue(me->vScroll);	dv = oldOrigin.v - me->theOrigin.v;		OffsetRect(&(**me->TEH).destRect, 0, dv);	tmpRgn=NewRgn();	if (dv!=0) 		{		ScrollRect( &(**me->TEH).viewRect, 0, dv, tmpRgn );		InvalRgn( tmpRgn );		}	DisposeRgn( tmpRgn );	}static SetVScroll()	{	register int max, n;		n=(**me->TEH).nLines-me->linesInFolder;	if ( ((**me->TEH).teLength>0) &&		( (*((**me->TEH).hText))[(**me->TEH).teLength-1]=='\r' )) n += 1;	max = ( n>0 ? n : 0 ); 		SetCtlMax( me->vScroll, max );	}static pascal void ScrollProc(theControl, theCode)	ControlHandle	theControl;	int				theCode;	{	int locVal;	GrafPtr theWindow;		if (theCode==scrollCode) 		{		locVal = GetCtlValue(theControl);		GetPort( &theWindow );		SetVScroll(me->TEH);		SetCtlValue( theControl, locVal+scrollAmt );		TxtUpdate();		}	}TxtShowSelect()	{	register int	theLine, point;	int				curLine, adjust;		SetVScroll();	curLine = GetCtlValue( me->vScroll );	point = (**me->TEH).selStart;	for (theLine=0; 		((point<(**me->TEH).lineStarts[theLine]) || 		(point>=(**me->TEH).lineStarts[theLine+1]))		; theLine++ ) ;	if ( (theLine<curLine ) || (theLine>(curLine+me->linesInFolder))) {		adjust = (me->linesInFolder-1)/2;		SetCtlValue( me->vScroll, theLine-adjust );		}	TxtUpdate();	}/* -------------------------------------------------------------------- */	long	TxtNew_File(), TxtOpen(), TxtClose_File();long	TxtSave(), TxtSave_As(), TxtRevert(); long	TxtRead_Stream(), TxtPrint_Stream(), TxtPrint_Line();long (*TxtObjTable[])() =	{	TxtNew, TxtDelete,	TxtDrag, TxtGrow, TxtContent, TxtKey_Down, TxtActivate, 		TxtUpdate, TxtClose, TxtIdle,	TxtUndo, TxtCut, TxtCopy, TxtPaste, TxtClear,	TxtNew_File, TxtOpen, TxtClose_File, TxtSave, TxtSave_As, TxtRevert,		TxtPrint,	TxtRead_Stream, TxtPrint_Stream, TxtPrint_Line	};	/* --------------------------------------------------------------------- */