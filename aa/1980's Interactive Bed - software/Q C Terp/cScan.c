/*CI Scanner.1/8/88 John Thompson.*/#include "cGlob.h"#include "cScan_.h"#include "cCharTable.h"/* -------------------------------------------------------------------------- */TermEnt	eofEnt = { TermEntType, 0, termClass, eofTerm };/* -------------------------------------------------------------------------- */Ent *cGetCharConst(), *cGetStringConst(), *cGetNumConst(), *cMakeTerm();Ent *cMakeSymbolOrKeyWord();/* -------------------------------------------------------------------------- */#define UngetLimit	4static short	ungetIndex = -1;static Ent		*ungetTab[UngetLimit];/* ------------------ cUngetToken ----------------------------------------- *//* Places a token back into stream */cUngetToken(tok)	Ent	*tok;	{	TRACE(1,("cUngetToken: tok=%lx et=%d\n",tok,tok->tabEnt.et));		ungetIndex += 1;		if (ungetIndex >= UngetLimit)		cFatalError("Too many cUngetToken");		ungetTab[ungetIndex] = tok;	}	/* --------------- cGetToken ------------------------------------------------ *//*Return next token from input stream.*/Ent	*cGetToken()	{	int		ch;	int		type;	char	str[MaxSymbolLen];	int		n;	Ent		*tok;		if (ungetIndex >= 0)		{		tok = ungetTab[ungetIndex];		ungetIndex -= 1;		return (tok);		}			/* Skip over white space */	for (;;)		{		type = CharTab[ch = cGetChar()];		if (type != WhiteChar)			break;		}		if (type == EofChar)		{		return (EofTok);		}			/* Filter out bad chars */	if (type == BadChar)		{		cScanError("Illegal character %c", ch);		return (BadTok);		}			/* Char Constant */	if (ch == '\'')		{		return (cGetCharConst());		}	/* String */			if (ch == '\"')		{		return (cGetStringConst());		}		/* Number. decimal, octal, hex or float */	if (type == DigitChar || ch == '.')		{		cUnGetChar(ch);		return (cGetNumConst());		}						/* Single char terminators */	if (type == TermChar)		{		return (cMakeTerm(ch));		}			/* We have a symbol */	str[0] = ch;	for (n = 1; ; n++)		{		type = CharTab[ch = cGetChar()];		if (type != SymbolChar && type != DigitChar)			{			cUnGetChar(ch);			break;			}		if (n < MaxSymbolLen)			str[n] = ch;		}	if (n > MaxSymbolLen) n = MaxSymbolLen;		return (cMakeSymbolOrKeyWord(n, str));	}/* ------------------ cGetCharConst --------------------------------------- */static Ent *cGetCharConst()	{	int		ch;	int		n;	long	val;	int		ctype;		val = 0;	for (n = 0; ; n++)		{		ch = cGetCharForString(SingleQuote);		if (ch == SingleQuote)			break;		val = (val << BitsPerChar) | ch;		if (n >= 4)			{			cScanError("Too many chars in single quote");			return (BadTok);			}		}		if (n>=2) return ( cMakeLongConst(val) );	else return ( cMakeShortConst( (int) val) );	}/* ------------------ cGetCharForString ------------------------------------ */static cGetCharForString(delim)	int		delim;	{	int		ch;	again:	ch = cGetCharQuoted();	if (ch == BackSlash)		{		ch = cGetCharQuoted();		switch (ch)			{			case 'n':				return ('\n');			case 't':				return ('\t');			case 'b':				return ('\b');			case 'r':				return ('\r');			case 'f':				return ('\f');			case NewLine:				/* Newline after backslash */				if (delim == DoubleQuote)					goto again;				return (ch);			default:				if (IsOctalDigit(ch))					{					ch = cGetOctalChar(ch);					}				return (ch);			}		}	}	/* ------------------ cGetOctalChar -------------------------------------- */static cGetOctalChar(ch)	{	int		val = (ch - '0');	int		n;		for (n = 1; n < 4; n++)		{		ch = cGetCharQuoted();		if (! IsOctalDigit(ch))			{			cUnGetChar(ch);			return (val);			}		val = (val << 3) | (ch - '0');		}	cScanError("Too many digits in octal char constant");	return (val);	}	/* ------------------ cGetStringConst -------------------------------------- */static Ent *cGetStringConst()	{	char	str[MaxStringLen];	int		n;	int		ch;		for (n = 0; ; n++)		{		ch = cGetCharForString(DoubleQuote);		if (ch == DoubleQuote)			{			return ( cMakeStringConst(n, str) );			}		if (ch == EndOfFile)			{			cScanError("Unterminated string");			break;			}		if (n < MaxStringLen)			str[n] = ch;		else {			cScanError("String too long");			break;			}		}	return (BadTok);	}		/* ------------------ cGetNumConst ----------------------------------------- */static Ent *cGetNumConst()	{	int		decimalSeen = 0, expSeen = 0, hexSeen = 0, octalSeen = 0;	int		ch, n;	unsigned long	val = 0;	unsigned long	max;	char	digBuf[MaxNumLen];		for (n = 0;; n++)		{		if (expSeen) expSeen += 1; /* Count exp chars */		if (n > MaxNumLen)			{			cScanError("Too many digits");			return (BadTok);			}		ch = cGetChar();		digBuf[n] = ch;		if (n == 0 && ch == '0')			{			octalSeen = 1;			continue;			}		if (n == 1 && octalSeen && (ch == 'x' || ch == 'X'))			{			octalSeen = 0;			hexSeen = 1;			continue;			}		if (octalSeen && ch >= '0' && ch <= '7')			{			val = (val << 3) | (ch - '0');			continue;			}		if (hexSeen)			{			if (ch >= 'a' && ch <= 'f')				val = (val << 4) | (ch - 'a' + 10);			else if (ch >= 'A' && ch <= 'F')				val = (val << 4) | (ch - 'A' + 10);			else if (ch >= '0' && ch <= '9')				val = (val << 4) | (ch - '0');			else				break;			continue;			}		if (ch >= '0' && ch <= '9')			{			val = (val * 10) + (ch - '0');			continue;			}		if (ch == '.')			{			if (decimalSeen || expSeen || hexSeen)				break;			decimalSeen = 1;			continue;			}		if (ch == 'e' || ch == 'E')			{			if (expSeen || hexSeen)				break;			expSeen = 1;			continue;			}		if (ch == '-' || ch == '+')			{			if (expSeen == 2)				continue;			cScanError("Illegal char in exponent");			return (BadTok);			}		if (ch == 'l' || ch == 'L')			{			if (decimalSeen || expSeen || hexSeen)				{				cScanError("Illegal char in long");				break;				}			return ( cMakeLongConst(val) );			}		break;		}	cUnGetChar(ch);			if (decimalSeen || expSeen)		{		return (cMakeDoubleConst(n, digBuf));		}			if (octalSeen || hexSeen)		if (val > MaxUShort) return (cMakeUnsignedLongConst(val));		else return (cMakeUnsignedShortConst((short)val));	else 		if (val > MaxShort)  return (cMakeLongConst(val));		else return (cMakeShortConst( (int)val )) ;	}	/* -------------------------------------------------------------------------- */