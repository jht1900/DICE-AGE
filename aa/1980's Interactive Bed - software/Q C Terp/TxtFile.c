/*TxtObj file operations.From LSC mini edit.*/	#include <MacTypes.h>#include <FileMgr.h>#include <TextEdit.h>#include <WindowMgr.h>#include <StdFilePkg.h>#include "TxtObj.h"#include "Obj.h"/* -------------------------------------------------------------------- */#define TRACE(a,b) if (a < 0) printf bextern TxtObj	*me;#define ErrorAlert		256#define	AdviseAlert		257#define aaSave		1#define aaDiscard	2#define aaCancel	3/* -------------------------------------------------------------------- */long TxtNew_File()	{	SetWTitle( me->myWindow, "\pUntitled");	ShowWindow( me->myWindow );	me->dirty = 0;	}	long TxtOpen()	{	int 	vRef, refNum, io;	Str255	fn;		if (OldFile( &fn, &vRef ))		if (FSOpen( &fn, vRef, &refNum)==noErr) 			{			if (read_file( refNum, me->TEH )) 				{				pStrCopy(fn, me->theFileName);				me->theVRefNum = vRef;				SetWTitle(me->myWindow, me->theFileName);				me->dirty = 0;				}			if (FSClose(refNum)==noErr) ;			ShowWindow( me->myWindow );			}		else FileError( "\pError opening ", fn );		}long TxtClose_File()	{	Str255	fn;	int		vRef;		if (me->dirty) 		{		switch (Advise("\pDo you want to save the changes to your file?"))			{			case aaSave:				if (me->theFileName[0]==0) 					{					fn[0] = 0;					if (!SaveAs(&fn, &vRef)) 						return(0);					}	 			else 	 				if (!SaveFile( me->theFileName, me->theVRefNum )) 	 					return(0);	 			break;	 		case aaCancel: 	 			return(0);	 			break;	 		case aaDiscard: 	 			me->dirty = 0;	 			break; 			} 		}	CloseMyWindow();	}	long TxtSave_As();	long TxtSave()	{	if (me->theFileName[0]==0)			TxtSave_As();	SaveFile(me->theFileName, me->theVRefNum);	}	long TxtSave_As()	{	int 	vRef;	Str255	fn;		fn[0] = 0;	if (SaveAs( &fn, &vRef )) 		{		pStrCopy(fn, me->theFileName);		me->theVRefNum = vRef;		SetWTitle(me->myWindow, me->theFileName);		}	}long TxtRevert()	{	int 	refNum;		HidePen();	TESetSelect( 0, (**me->TEH).teLength, me->TEH );	ShowPen();	TEDelete(me->TEH);	if ((me->theFileName[0]!=0) &&		(FSOpen( &me->theFileName, me->theVRefNum, &refNum)==noErr)) 		{		me->dirty = !read_file( refNum, me->TEH ); 		/* I don't check for bad read! */		if (FSClose(refNum)==noErr) ;		}	ShowWindow( me->myWindow );	TxtUpdate();	}	static Point SFGwhere = { 90, 82 };static Point SFPwhere = { 106, 104 };static SFReply reply;static SaveAs( fn, vRef )	Str255 	*fn;	int		*vRef;	{	int refNum;		if (NewFile(fn, vRef)) 		if (CreateFile(fn, vRef, &refNum)) 			{			SetEOF(refNum, 0L);			WriteFile(refNum, (*(**me->TEH).hText), (long)(**me->TEH).teLength);			FSClose( refNum );			me->dirty = 0;			return(1);			}		else {			FileError("\pError creating file ", fn);			}	return(0);	}static SaveFile( fn, vrn )	Str255	fn;	int		vrn;	{	int refNum;		if (FSOpen( fn, vrn, &refNum )==noErr) 		{		SetEOF(refNum, 0L);		WriteFile(refNum, (*(**me->TEH).hText), (long)(**me->TEH).teLength);		me->dirty = 0;		FSClose( refNum );		return(1);		}	else FileError("\pError opening file ", fn);	return(0);	}static NewFile( fn, vRef )	Str255	*fn;	int		*vRef;	{	SFPutFile(SFPwhere, "\p", fn, 0L, &reply);	if (reply.good) 		{		pStrCopy(reply.fName, fn);		*vRef = reply.vRefNum;		return(1);		}	else return(0);	}static OldFile( fn, vRef )	Str255	*fn;	int		*vRef;	{	SFTypeList	myTypes;		myTypes[0]='TEXT';	SFGetFile( SFGwhere, "\p", 0L, 1, myTypes, 0L, &reply );	if (reply.good) 		{		pStrCopy( reply.fName, fn );		*vRef = reply.vRefNum;		return(1);		}	else return(0);	}static CreateFile( fn, vRef, theRef )	Str255	*fn;	int		*vRef;	int		*theRef;	{	int io;		io=Create(fn, *vRef, '????', 'TEXT');	if ((io==noErr) || (io==dupFNErr)) io = FSOpen( fn, *vRef, theRef );	return( (io==noErr) || (io=dupFNErr) );	}static WriteFile( refNum, p, num )	int		refNum;	char	*p;	long	num;	{	int io;			/* 	a real application would want to check 						this return code for failures */		io=FSWrite( refNum, &num, p );	}static read_file( refNum, textH )	int			refNum;	TEHandle	textH;	{	char	buffer[256];	long	count;	int		io;		TESetSelect(0, (**textH).teLength, textH);	TEDelete( textH );	do {		count = 256;		io = FSRead( refNum, &count, &buffer );		TEInsert( &buffer, count, textH );		} while (io==noErr);	return( io==eofErr );	}pStrCopy( p1, p2 )	register char *p1, *p2;	/* copies a pascal string from p1 to p2 */	{	register int len;		len = *p2++ = *p1++;	while (--len>=0) *p2++=*p1++;	}static FileError( s, f )	Str255 s, f;	{	ParamText(s, f,"\p", "\p");	Alert( ErrorAlert, 0L );	}static Advise( s )	Str255 s;	{	ParamText(s,"\p","\p","\p");	return( Alert(AdviseAlert, 0L) );	}