/**//* --------------------------------------------------------------------- *//* --------------------------------------------------------------------- */typedef unsigned char	uchar;typedef uchar			*Name;typedef short			Bool;#define NULL			((char *) 0L)/* --------------------------------------------------------------------- *//* --------------------------------------------------------------------- *//* Machine sizing  */#define BitsPerChar		8#define PointerSize	4#define MaxShort		32767#define MaxUShort		65535#define MinShort		-32768#define MaxChar			127#define MinChar			-128#define DefaultIntSize	2#define MaxIntSize		4	/* Minium alignment for structures */#define StructBoundary	2/* --------------------------------------------------------------------- *//* --------------------------------------------------------------------- */typedef enum TermTypeCode	{	notTerm,		/* Storage class */	autoKey,	staticKey,	externKey,	registerKey,	typedefKey,		/* Basic type */	voidKey,	charKey,	shortKey,	intKey,	longKey,	unsignedKey,	floatKey,	doubleKey,	structKey,	unionKey,	enumKey,		/* Statements */	ifKey,	whileKey,	doKey,	forKey,	switchKey,	caseKey,	breakKey,	continueKey,	returnKey,	gotoKey,		pascalKey,		exclamTerm,	percentTerm,	ampersandTerm,	lparenTerm,	rparenTerm,	asteriskTerm,	plusTerm,	commaTerm,	minusTerm,	dotTerm,	slashTerm,	colonTerm,	semicolonTerm,	lessTerm,	equalTerm,	greaterTerm,	questionTerm,	lsquareTerm,	rsquareTerm,	caretTerm,	lcurlyTerm,	rcurlyTerm,	vbarTerm,	squiggleTerm,		ellipsisTerm, 	/* ... */		eofTerm,		forceWordTerm = 256	}	TermTypeCode;/* --------------------------------------------------------------------- */typedef enum TermClass	{	storageClass,	typeClass,	stmtClass,	termClass,		forceWordClass = 256	}	TermClass;	/* --------------------------------------------------------------------- *//* --------------------------------------------------------------------- */typedef enum EntType	{	IdEntType,	TermEntType,	ConstEntType,	ExprEntType,	StmtEntType,	EnumEntType,	FuncDefType,	VarDefType,	EnumDefType,	TypedefDefType,		SimpleTypeType,	StructEntType,		/* AggreTypeEnt */	UnionEntType,		/* AggreTypeEnt */	FuncTypeType,	ArrayTypeType,	PtrTypeType,		ForceWord = 256	}	EntType;	/* --------------------------------------------------------------------- */typedef union Ent TypeEnt;enum TypeStorage { autoStore, staticStore, externStore, regStore, typedefStore };enum TypeLang { cLang, pascalLang };enum BaseTypeType { 	voidType, intType, floatType, aggreType, arrayType, funcType, derefType };/* --------------------------------------------------------------------- *//* Type's */typedef struct SimpleTypeEnt	{	EntType			et;	short			type;	short			size;	short			unsign;	}	SimpleTypeEnt;	/* Also assigned to struct/union */typedef struct AggreTypeEnt	{	EntType			et;	union Ent		*name;			long			size;	struct cList	*memList;	}	AggreTypeEnt;	typedef struct AggreMember	{	struct AggreMember *next;	union Ent		*nameId;	TypeEnt			*type;	long			offset;	short			fieldWidth;	short			bitOffset;	}	AggreMember;	typedef struct ArrayTypeEnt	{	EntType			et;	TypeEnt			*to;	long			dim;	}	ArrayTypeEnt;	typedef struct FuncTypeEnt	{	EntType			et;	TypeEnt			*to;	struct cList	*argList;	}	FuncTypeEnt;typedef struct PtrTypeEnt	{	EntType			et;	TypeEnt			*to;	}	PtrTypeEnt;/* --------------------------------------------------------------------- *//*	Possible defintions for id's*/typedef struct FuncDefEnt	{	EntType			et;	TypeEnt			*type;	short			storage;	short			lang;	struct cList	*argList;	struct ExprEnt	*def;	}	FuncDefEnt;	typedef struct VarDefEnt	{	EntType			et;	TypeEnt			*type;	short			storage;	struct ExprEnt	*def;	}	VarDefEnt;	typedef struct TypedefDefEnt	{	EntType			et;	TypeEnt			*type;	}	TypedefDefEnt;		/* enum member have const et's */	/* --------------------------------------------------------------------- */	typedef struct IdEnt	{	EntType			et;	Name			name;	union Ent		*def; /* Only ..DefEnt are here */	}	IdEnt;/* --------------------------------------------------------------------- */typedef struct TabEnt	{	EntType			et;	Name			name;	}	TabEnt;typedef struct TermEnt	{	EntType			et;	Name			name;	short			class;	short			type;	}	TermEnt;	typedef struct ConstEnt	{	EntType			et;	Name			name;	union TypeEnt	*type;	short			size;	}	ConstEnt;	/* assigned to enum types *//* Enum members are defined with const ent types */typedef struct EnumEnt	{	EntType			et;	union Ent		*name;	TypeEnt			*type;	}	EnumEnt;	typedef union Ent	{	TabEnt			tabEnt;	IdEnt			idEnt;	TermEnt			termEnt;	EnumEnt			enumEnt;	ConstEnt		constEnt;			/* Values of types */	SimpleTypeEnt	simpleType;	AggreTypeEnt	aggreType;	ArrayTypeEnt	arrayType;	FuncTypeEnt		funcType;	PtrTypeEnt	derefType;			/* Values of an id's def */	FuncDefEnt		funcDef;	VarDefEnt		varDef;	TypedefDefEnt	typedefDef;		/* enum members have const et */	}	Ent;	/* --------------------------------------------------------------------- */typedef struct cSpace	{	struct	cSpaceHdr	*first;	struct	cSpaceHdr	*last;	long				allocSize;	}	cSpace;	typedef struct cSpaceHdr	{	struct cSpaceHdr	*next;	long				allocSize;	long				nalloc;	char				s[];	}	cSpaceHdr;/* --------------------------------------------------------------------- */typedef struct cList	{	struct cList		*next;	Ent					*ent;	}	cList;	typedef struct HashTab	{	long				tabSize;	cList				*tab[];	}	HashTab;/* --------------------------------------------------------------------- */typedef struct cEnv	{	HashTab				*idTab;			/* for identifies, including keywords */	HashTab				*auxTab;		/* for struct, union, enum names */	HashTab				*constTab;		/* for constants */		cSpace				objSpace;	}	cEnv;/* --------------------------------------------------------------------- */typedef struct QueEnt	{	struct QueEnt		*next;	}	QueEnt;	typedef struct Que	{	QueEnt				*first;	QueEnt				*last;	}	Que;	typedef struct TypeDeclArg	{	short				allowNullId;	TypeEnt				*baseType;	short				storage;	short				lang;	TypeEnt				*type;	IdEnt				*id;	}	TypeDeclArg;	#define IsTerm(tok) ((tok)->tabEnt.et == TermEntType)#define TermType(tok) (IsTerm(tok)? (tok)->termEnt.type : notTerm )#define cNewObj(nam) (nam *) cAllocInSpace(&ce.objSpace, (long) sizeof(nam) )/* ----------------------------------------------------------------- *//* Scanner interface definitions.*/	Ent 			*cGetToken();extern TermEnt	eofEnt;#define BadTok	((Ent *) &eofEnt)#define EofTok	((Ent *) &eofEnt)/* ----------------------------------------------------------------- *//* Node Maker def's*/	Ent		*cMakeSymbolOrKeyword(int term, int postBreak);Ent		*cMakeCharConst(char val);Ent		*cMakeShortConst(int val);Ent		*cMakeLongConst(long val);Ent		*cMakeUnsignedShortConst(int val);Ent		*cMakeUnsignedLongConst(long val);Ent		*cMakeStringConst(int len, char *str);Ent		*cMakeDoubleConst(int len, char *str);char	*cAllocInSpace(cSpace *cspace, long allocSize);Ent 	*cIntern(HashTab *htab, short len, Name name, short entSize, Bool *new);Ent 	*cInternByEt(HashTab *htab, short et, Ent *name, short entSize, Bool *new);Ent		*cInternConst(Ent *type, short len, Name name);/* ----------------------------------------------------------------- */long	cGetIntConst();long	cTypeSize();/* ----------------------------------------------------------------- */#define TRACE(a,b) if (cTraceLevel >= a) xprintf bextern short	cTraceLevel;/* --------------------------------------------------------------------- */