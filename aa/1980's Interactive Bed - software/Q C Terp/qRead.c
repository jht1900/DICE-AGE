/* Read a lisp expression.*/#include "qDef.h"#include "Stream.h"#include "asciiTable.h"extern Env	*ev;extern char qtrace;#define TRACE(a,b) if (qtrace>=a) printf bqItem	ReadQuote();qItem	ReadStream( st)	register Stream	*st;	{	Byte			str[MaxStringLen+2];	Byte			*bstop, *sp;	register Byte	*bp;	register int	n, c, ndig;	long			lw;		TRACE(2,("ReadStream: ev=%lx st=%lx\n", ev, st));	recurse:	bp = st->buf + st->bufPos;	bstop = st->buf + st->nread;		/* Skip over white space */	for (;; bp++)		{		if (bp >= bstop) 			{			if (st->nread < st->bufMax)				break;			(*st->readf)(st);			bp = st->buf;			}		if ((c = asciiTable[*bp]) != qWHITE)			break;		}			/* Accumulate a token string */	n = 0;	ndig = 0;	sp = str + 1;	for (; n < MaxStringLen; n++, bp++) 		{		if (bp >= bstop) 			{			if (st->nread < st->bufMax)				break;			(*st->readf)(st);			bp = st->buf;			}		c = *bp;		*sp++ = c;		if (c == st->eofChar)			break;		if ((c = asciiTable[c]) & qBREAK)			break;		if (c == qDIGIT) ndig++;		}	*--sp = 0;	str[0] = n;	st->bufPos = (bp - st->buf);		if (n < 1)		{		/* No token built up */				st->bufPos += 1; /* Eat last character */		 				switch (c)			{			case qLPAREN:				return (ReadStreamList( st));				break;							case qRPAREN:				st->bufPos--;	/* Backup to rparen */				break;							case qCOMMENT:				skipCommentChars( st);				goto recurse;				break;						case qQUOTE:				return (ReadQuote( st));			}					return (st->eofId);		}	if (ndig == n || (str[1] == '-' && ndig == n-1 && ndig > 0))		{		long atol();				/* Parsed a number */		return (Numify(atol(str + 1)));		}			if (str[1] == '$')		{		sscanf(str+2, "%lx", &lw);		return (Numify(lw));		}		if (str[1] == '#')		{		return (Numify(str[2]));		}			/* Symbol */	return (InternSymbol( str));	}	static qItem	ReadQuote( st)	Stream		*st;	{	extern qItem quoteSym;	qItem		it;	return ( (qItem) List2( quoteSym, ReadStream( st)) );	}	qItem	ReadStreamList(st)	register Stream	*st;	{	qItem	p, q;		TRACE(2,("ReadStreamList: ev=%lx st=%lx\n", ev, st));		p = NIL;	for (;;)		{		q = ReadStream( st);		if (q == st->eofId)			{			if (asciiTable[st->buf[st->bufPos]] != qRPAREN)				{				(*st->alertf)(0,"End of file in the middle of list.");				}			st->bufPos++;			return ((qItem) Nreverse(p));			}		p = (qItem) Cons( q, p);		}	}	static	skipCommentChars( st)	register Stream	*st;	{	Byte	*bstop;	register Byte *bp;		TRACE(2,("skipCommentChars: ev=%lx st=%lx\n", ev, st));	bp = st->buf + st->bufPos;	bstop = st->buf + st->nread;			for (;; bp++)		{		if (bp > bstop)			{			if (st->nread < st->bufMax)				break;			(*st->readf)(st);			bp = st->buf;			}		if (*bp == st->eofChar)			break;		}			st->bufPos = (bp - st->buf) + 1;	}	