; Magic Hardware Reset SubroutineHreset:	movem.l a0-a3/d0-d4,-(sp)	move.l SWCTL(a5),a0	move SR,-(sp)	ori #0700,SR		;disable interrupts	move.b #5,(a0)	move.b #$7A,(a0)	;send break	move.w #17,d0Hrs1	dbf d0,Hrs1	move.b #5,(a0)		;	move.b #$6A,(a0)	;remove break	move (sp)+,SR		;enable interrupts again	move.w #30,d4	jsr wait		;wait for a half second	move.w SccInFlg(a5),d1	;save SCC init state	clr.w SccInFlg(a5)	;turn off OUTCHR error dialog	move.w #$A6,d0		;	jsr outchr		;send GET VERSION command	bne Hr5			;error- no clock 	move.w d1,SccInFlg(a5)	;restore SCC init flag		move.l SRctl(a5),a0	;get read ctl addr.	move.w #$8000,d0	;Hr2:	subq.w #1,d0		;timout?	beq Hr5			;yes	btst.b #0,(a0)		;Char ready?	beq Hr2			;no	move.l SRdata(a5),a0	;	move.b (a0),d0		;get version	addq.w #1,CamErr(a5)	;inc camera not connected error	cmpi.w #2,CamErr(a5)	blt Hr3			;error	move.w #129,d0	jsr StpAlert	bra Hr6Hr3	movem.l (sp)+,a0-a3/d0-d4	ori #4,CCR		;set zero- Reset O.K	rts	Hr5:	move.w d1,SccInFlg(a5)	;restore SCC init flag	addq.w #1,HardErr(a5)	cmpi.w #2,HardErr(a5)	;error?	blt Hr3			;no	move.w #132,d0	jsr StpAlert		;Hardware Error	Hr6:	movem.l (sp)+,a0-a3/d0-d4	andi #$0FB,CCR		rts	;	subroutine to wait 1/60 second increments given in D0;Wait:	move.l a0,-(sp)		;save a0	ext.l d4		;count given in 16 bit d0	subq.l #4,sp	_TickCount		;get time	add.l (sp)+,d4		;compute time to leaveWait1:	_SystemTask	subq.l #4,sp	_TickCount		;get time	cmp.l (sp)+,d4		;time to leave?	bgt Wait1	move.l (sp)+,a0	rts		INSCC:	DC.B 4,4,11,$28	DC.B 14,0,3,$C1	DC.B 5,$6A,$30	dc.b 15,8,0				InitScc:	tst.w SccInFlg(a5)	;already initialized?	beq ins0		;no	rts			;yes- returnins0:	MOVE.L SWCTL(a5),A3	;GET SCC  CHANNEL WRITE CONTROL ADDRESS	LEA INSCC,A0		;GET ADDRESS OF INITIALIZATION BYTE STREAM	MOVEQ #13-1,D0		;GET COUNT OF STRINGIN1:	MOVE.B (A0)+,(A3)	;SEND BYTE TO SCC	DBF D0,IN1		;LOOP TILL DONE	move.w #1,SccInFlg(a5)	;mark as initialized	RTSoutchr:	move.l SRctl(a5),a1	move.l SWdata(a5),a4	move.w d0,-(sp)	move.w #$8000,d0outc1:	subq.w #1,d0		;timeout countdown	beq outcerr	btst.b #2,(a1)	beq outc1		;	move.w (sp)+,d0	move.b d0,(a4)		;send char	move.l d0,-(sp)		;	move.w #50,d0outc2:	dbf d0,outc2		;wait for poor z-80	move.l (sp)+,d0	ori #$4,CCR		;set zero flagoutc3:	rts	outcerr:	move.w (sp)+,d0	tst.w SccInFlg(a5)	;initialized?	beq outc4		;no- so don't report error again	movem.l d0-d4/a0-a4,-(sp)	_ShowCursor		;make cursor visble if it was'nt already	lea Fdrect,a4	jsr saverec		;save stuff under alert box	move.w #128,-(sp)	;timout ID	clr.l -(sp)		;Filter PROC (use standard)	_StopAlert		;	jsr restorec	clr.w SccInFlg(a5)	;set flag to re-initialize Scc	movem.l (sp)+,d0-d4/a0-a4outc4:	andi #$0FB,CCR		;set non-zero	rts	;	set the low cut valuesetLOW:	swap d0	move.b #$A2,d0	;command codesetl1:	jsr outchr	bne setl2	swap d0	jsr outchrsetl2:	rts	;	set the high cut valuesetHI:	jsr blend;	tst.w d3		;last cut?;	bpl seth1		;no;	move.w #255,d0seth1:	swap d0	move.b #$A0,d0	bra.s setl1	; TRANSFER A PICTURE INTO THE MAC for reading pictures whose  horz. size is ;				  not divisible by 3 i.e. 512 wide; reads in D3 fields at 3 bytes/swipe and then 1 more 8 bit swipe;; D1=COMP & odd/even FLAG	;D3= # OF FIELDS; D2=INITIAL STRIPE 		;D4= # OF LINES; D5= # of lines to delay down till picture starts; D6= High and Low Cut Value; A0= address to put data intoGETp1SCN:	clr.w HardErr(a5)	;	clr.w CamErr(a5)GetAgn:	movem.w d1-d5,-(sp)	;save args	movem.l a0/d6,-(sp)		MOVE SR,-(SP)	ORI #$0700,SR		;KILL INTERRUPTS	move.w d6,d0		;get low cut	jsr setlow	bne Gtmout1	swap d6	move.w d6,d0	jsr sethi		;set high cut	bne Gtmout1	lea SWdata(a5),a1	;get address of list of Scc addresses	move.l (a1)+,a4		;get Scc Register Addresses	move.l (a1)+,a3	move.l (a1)+,a2	move.l (a1)+,a1	ADD.w MvHorVal(a5),d2	;center screen	MOVE.W D4,D6		;GET # OF LINES/FIELD	ADD.W D6,D6		;DOUBLE FOR LINES/FRAME	SUBQ.W #1,D6		;LINES -1	MOVE.W #-128,A6		;	LSL.W #6,D6		;*64 = ADDRESS BACKUP AT BOTTOM  OF FRAME	move.b (a2),d0		;	move.b (a2),d0	move.b (a2),d0	move.b (a2),d0		;clean out SCC	MOVE.B #$A4,D0		;SEND PICTURE COMMAND	JSR OUTCHR	bne Gtmout		;timout error	MOVE.B D2,D0		;INITIAL STRIPE 1	JSR OUTCHR	bne Gtmout	addq.w #2,d3		;tell em 1 more for last 1 byte swipe	MOVE.B D3,D0		;# OF FIELDS 2	JSR OUTCHR	bne Gtmout	subq.w #2,d3		;	LSR.W #1,D3		;MAKE FRAMES	SUBQ.W #1,D3		;MAKE DBF D3,XXX VALUE	MOVE.B D4,D0		;# OF LINES 3	JSR OUTCHR	bne Gtmout	move.b d5,d0		;delay down 4	JSR OUTCHR	bne Gtmout	SUBQ.W #1,D4		;MAKE DBF COUNTERGETS1:	move.l (sp),(sp)	;time delay	btst.b #2,(a1)	beq GETS1		;	move.b d1,(a4)		;send COMPLEMENT FLAG 5G0:	MOVE.W #2-1,D0		;2 FIELDSG0A:	MOVE.W D4,D2		;ONE FIELD LINE COUNTGOB:	move.w #3-1,d7		;	move.l #$20000,d1	;timout constantG1:	subq.l #1,d1		;count down timout	beq Gtmout		;timout	BTST.B #0,(A1)		;CHAR READY?	BEQ G1			;NO	MOVE.B (A2),(A0)+	;GET DATA BYTE	DBF D7,G1	ADDA #128,A0		;SKIP A LINE	SUBA.W #3,A0	DBF D2,GOB		;FOR 1 FIELD	SUBA.W D6,A0		;BACKUP TO DO NEXT FIELD	DBF D0,G0A		;FOR FRAME	ADDA.W A6,A0		;STEP OVER NUMBER OF BYTES WE TOOK	ADDA.W #3,A0		; 	DBF D3,G0		;COUNT DOWN FRAMES; now do last 1 byte swipe	GL0:	MOVE.W #2-1,D0		;2 FIELDSGL0A:	MOVE.W D4,D2		;ONE FIELD LINE COUNTGLOB:				move.l #$20000,d1	;timout constantGL1:	subq.l #1,d1		;count down timout	beq Gtmout		;timout	BTST.B #0,(A1)		;CHAR READY?	BEQ GL1			;NO	MOVE.B (A2),(A0)+	;GET DATA BYTE	move.l #$20000,d1	;timout constantGL2:	subq.l #1,d1		;count down timout	beq Gtmout		;timout	BTST.B #0,(A1)		;CHAR READY?	BEQ GL2			;NO	MOVE.B (A2),D5		;TAKE DATA BYTE BUT DON'T USE IT	move.l #$20000,d1	;timout constantGL3:	subq.l #1,d1		;count down timout	beq Gtmout		;timout	BTST.B #0,(A1)		;CHAR READY?	BEQ GL3			;NO	MOVE.B (A2),D5		;TAKE DATA BYTE BUT IGNORE IT	ADDA.W #128-1,A0	;SKIP A LINE	DBF D2,GLOB		;FOR 1 FIELD	SUBA.W D6,A0		;BACKUP TO DO NEXT FIELD	DBF D0,GL0A		;FOR each Field	MOVE (SP)+,SR	add.w #18,sp		;remove arguments	clr.w d0		;no error	RTS	Gtmout:	MOVE (SP)+,SR	jsr Hreset		;reset Magic	movem.l (sp)+,a0/d6	movem.w (sp)+,d1-d5	;yes - try to get picture again	beq Getagn		;did Reset work?Gtmout0	_ShowCursor		;no	move.w #1,d0		;timout error	rts	Gtmout1	MOVE (SP)+,SR		;interface not connected error	movem.l (sp)+,a0/a6	movem.w (sp)+,d1-d5	;	bra Gtmout0; TRANSFER A PICTURE INTO THE MAC;; D1=COMP & odd/even FLAG	;D3= # OF FIELDS; D2=INITIAL STRIPE 		;D4= # OF LINES; D5= # of lines to delay down till picture starts; d6= high/low cut values; A0= address to put data intoGETSCN:	clr.w HardErr(a5)	clr.w CamErr(a5)	;reset error flagsGETAGN:	movem.w d1-d5,-(sp)	;save args	movem.l a0/d6,-(sp)	MOVE SR,-(SP)	ORI #$0700,SR		;KILL INTERRUPTS	move.w d6,d0		;get low cut	jsr setlow	bne Gtmout1	swap d6	move.w d6,d0	jsr sethi		;set high cut	bne Gtmout1	lea SWdata(a5),a1	;get address of list of Scc addresses	move.l (a1)+,a4		;get Scc Register Addresses	move.l (a1)+,a3	move.l (a1)+,a2	move.l (a1)+,a1	ADD.w MvHorVal(a5),d2	;center screen	MOVE.W D4,D6		;GET # OF LINES/FIELD	ADD.W D6,D6		;DOUBLE FOR LINES/FRAME	SUBQ.W #1,D6		;LINES -1	MOVE.W #-128,A6		;	LSL.W #6,D6		;*64 = ADDRESS BACKUP AT BOTTOM  OF FRAME	move.b (a2),d0		;	move.b (a2),d0	move.b (a2),d0	move.b (a2),d0		;clean out SCC	MOVE.B #$A4,D0		;SEND PICTURE COMMAND	JSR OUTCHR	bne Gtmout		;timout error	MOVE.B D2,D0		;INITIAL STRIPE 1	JSR OUTCHR	bne Gtmout	MOVE.B D3,D0		;# OF FIELDS 2	JSR OUTCHR	bne Gtmout	LSR.W #1,D3		;MAKE FRAMES	SUBQ.W #1,D3		;MAKE DBF D3,XXX VALUE	MOVE.B D4,D0		;# OF LINES 3	JSR OUTCHR	bne Gtmout	move.b d5,d0		;delay down 4	JSR OUTCHR	bne Gtmout	SUBQ.W #1,D4		;MAKE DBF COUNTERGETS1:	move.l (sp),(sp)	;time delay	btst.b #2,(a1)	beq GETS1		;	move.b d1,(a4)		;send COMPLEMENT FLAG 5G0:	MOVE.W #2-1,D0		;2 FIELDSG0A:	MOVE.W D4,D2		;ONE FIELD LINE COUNTGOB:	move.w #3-1,d7		;	move.l #$20000,d1	;timout constantG1:	subq.l #1,d1		;count down timout	beq Gtmout		;timout	BTST.B #0,(A1)		;CHAR READY?	BEQ G1			;NO	MOVE.B (A2),(A0)+	;GET DATA BYTE	DBF D7,G1	ADDA #128,A0		;SKIP A LINE	SUBA.W #3,A0	DBF D2,GOB		;FOR 1 FIELD	SUBA.W D6,A0		;BACKUP TO DO NEXT FIELD	DBF D0,G0A		;FOR FRAME %%%%	ADDA.W A6,A0		;STEP OVER NUMBER OF BYTES WE TOOK	ADDA.W #3,A0		; 	DBF D3,G0		;COUNT DOWN FRAMES		MOVE (SP)+,SR	add.w #18,sp		;remove arguments	clr.w d0		;no error	RTS	Gtmout:	MOVE (SP)+,SR	jsr Hreset		;reset Magic	movem.l (sp)+,a0/d6	movem.w (sp)+,d1-d5	;yes - try to get picture again	beq GETAGN		;did Reset work?Gtmout0	_ShowCursor		;no	move.w #1,d0		;timout error	rts	Gtmout1	MOVE (SP)+,SR		;interface not connected error	movem.l (sp)+,a0/a6	movem.w (sp)+,d1-d5	;	bra Gtmout0		; ; TRANSFER A PICTURE INTO THE MAC;GETStrp:GETStrp:	clr.w HardErr(a5)	clr.w CamErr(a5)	;reset error flagsGETAGN:	movem.w d1-d5,-(sp)	;save args	movem.l a0/d6,-(sp)	MOVE SR,-(SP)	ORI #$0700,SR		;KILL INTERRUPTS	tst.b chgcutlev(a5)	;	beq.s @1		;no need to set cut levels	move.b s.locut(a0),d0	;get low cut	jsr setlow		;set low cut	bne Gtmout1	clr.w d0		;	move.b s.hicut(a0),d0	jsr sethi		;set high cut	bne Gtmout1@1	lea SWdata(a5),a1	;get address of list of Scc addresses	move.l (a1)+,a4		;get Scc Register Addresses	move.l (a1)+,a3	move.l (a1)+,a2	move.l (a1)+,a1	move.b (a2),d0		;	move.b (a2),d0	move.b (a2),d0	move.b (a2),d0		;clean out SCC	MOVE.B #$A4,D0		;SEND PICTURE COMMAND	JSR OUTCHR	bne Gtmout		;timout error	MOVE.B s.stpcurab(a0),D0;INITIAL STRIPE 1	ADD.w MvHorVal(a5),D0	;center screen	JSR OUTCHR	bne Gtmout	clr.l d0		;	MOVE.B s.wide(a0),D0	;# OF FIELDS 2	move.w d0,d3		;	subq.w #1,d3		;make dbf style counter	divu #3,d0		;HOW MANY 3 BYTE WIDE STRIPES?	MOVE.L D0,D1		;	SWAP D1	TST.W D1		;ANY REMAINDER?	BEQ.S @3	ADDQ.W #1,D0		;YES@3	add.w d0,d0		;convert to frames	JSR OUTCHR	bne Gtmout	MOVE.B s.numlines(a0),D0;# OF LINES 3	JSR OUTCHR	bne Gtmout	SUBQ.W #1,D0		;MAKE DBF COUNTER	move.w d0,d4		;	move.b s.skipln(a0),d0	;delay down 4	JSR OUTCHR	bne GtmoutGETS1:	move.l (sp),(sp)	;time delay	btst.b #2,(a1)	beq GETS1		;	move.b s.flags(a0),(a4)	;send COMPLEMENT FLAG 5	move.w s.byts_row(a0),d5;	ADD.W D5,D5		;MAKE ADDRESS SKIP COUNT FOR 1 LINE	MOVE.L S.curaddr(a0),a3;	move.l a3,a4		;	move.l a3,a6G0:	MOVE.W #2-1,D0		;2 FIELDSG0A:	MOVE.W D4,D2		;ONE FIELD LINE COUNTGOB:	move.l a3,a4		;save current address	move.w #3-1,d7		;	clr.w d6		;assume 3 stripes	cmpi.b #3-1,d3		;do 3 strips?	bge.s @2	add.w d3,d6	sub.w d3,d7@2	move.l #$20000,d1	;timout constantG1:	subq.l #1,d1		;count down timout	beq Gtmout		;timout	BTST.B #0,(A1)		;CHAR READY?	BEQ G1			;NO	MOVE.B (A2),(A4)+	;GET DATA BYTE	DBF D7,G1	bra.s @4	@1	move.l #$20000,d1	;timout constant@2	subq.l #1,d1		;count down timout	beq Gtmout		;timout	BTST.B #0,(A1)		;CHAR READY?	BEQ @2			;NO	MOVE.B (A2),d1		;throw away  DATA BYTE@4	dbf d6,@1@5	ADDA.w d5,A3		;SKIP OVER 1 LINE 	DBF D2,GOB		;COUNT DOWN LINES PER FIELD	move.l a6,a3	adda.w s.byts_row(a0),a3;	MOVE (SP),SR		;enable interrupts	move.l #$10,d1		;@6	subq.l #1,d1		;let the mouse get in	beq @7			Bra.s @6		;@7	ORI #$0700,SR		;KILL INTERRUPTS again	DBF D0,G0A		;COUNT ODD/EVEN FIELD	ADDA.W #3,A6		;	move.l a6,a3		;reset base of next frame	subq.w #3,d3		;	bgt G0			;last 3 byte frame?	MOVE (SP)+,SR	add.w #18,sp		;remove arguments	clr.w d0		;no error	clr.b chgcutlev(a5)	;	RTS	Gtmout:	MOVE (SP)+,SR	jsr Hreset		;reset Magic	movem.l (sp)+,a0/d6	movem.w (sp)+,d1-d5	;yes - try to get picture again	beq GETAGN		;did Reset work?Gtmout0	move.b #1,chgcutlev(a5)	;reload cut levels	_ShowCursor		;no	move.w #1,d0		;timout error	rts	Gtmout1	MOVE (SP)+,SR		;interface not connected error	movem.l (sp)+,a0/d6	movem.w (sp)+,d1-d5	;	bra Gtmout0; SCC Serial Chip AddressesSCCRBase	EQU	$9FFFF8	; SCC base read addressSCCWBase	EQU	$BFFFF9	; SCC base write addressSccRd		equ	$1D8	;Scc Read Base Pointer SccWr		equ	$1DC	;Scc Write Base PointeraData		EQU	6	; offset for A channel dataaCtl		EQU	2	; offset for A channel controlbData		EQU	4	; offset for B channel databCtl		EQU	0	; offset for B channel control