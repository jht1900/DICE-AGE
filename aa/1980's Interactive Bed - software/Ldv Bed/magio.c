/*Magic digitizer interface.*/#include <Quickdraw.h>#include <WindowMgr.h>#include "MagInfo.h"MagInfo maginfo = 	{	2,		/* oddComp */#if 0	12,		/* stripOffset */	40,		/* nfields */	150,	/* nlines */	20,		/* startLine */	100,	/* High */	0,		/* low cutoff */#else	28,		/* stripOffset */	16,		/* nfields */	72,		/* nlines */	64,		/* startLine */	47,		/* High */	0,		/* low cutoff */#endif	(Byte *)0xFA700	+ (40-1)*64 /* dest */	};#define MaxLine		(384)#define MaxRow		(64)#define MaxScreen	((long)MaxLine * (long)MaxRow)Byte	*dest1;		/* Destination for single grab */MagInit()	{	MagSccInit();	dest1 = NewPtr( MaxRow * ((long)MaxLine) );	if (! dest1)		{		printf("MagInit: alloc failed\n");		}			maginfo.dest = dest1;	maginfo.bits.baseAddr = dest1;	maginfo.bits.rowBytes = MaxRow;	SetRect(&maginfo.bits.bounds, 0, 0, MaxRow*8, MaxLine);	}MagGrab()	{	if (MagGrab1())		{		doalert("\pMagic DIGITIZER not responding",			"\pPlease check video cable or",			"\pserial cable to printer port",			"\p");		}	}	/* Multi screen buffers */static Byte *bag = 0;static int	nbag = 0;/*Set up big buffer for multi grab.*/MagBagAlloc(n)	{	nbag = n;	if (bag) DisposPtr(bag);	bag = NewPtr( nbag * MaxScreen );	if (! bag)		{		printf("MagBagInit: alloc failed\n");		nbag = 0;		return;		}	}/*Grab nbag screen fulls into bag buffer.*/MagBagGrab()	{	int i;	Byte	*d = bag;	extern Cursor	waitCursor;		SetCursor(&waitCursor);	for (i = 0; i < nbag; i++, d += MaxScreen)		{		maginfo.dest = d;		maginfo.bits.baseAddr = d;		MagGrab();		}	SetCursor(&arrow);	}	/*Display a screen in the bag*/MagBagShow(n, win)	int			n;	WindowPtr	win;	{	maginfo.dest = bag + n*MaxScreen;	maginfo.bits.baseAddr = maginfo.dest;	MagCopy(win);	}	MagShowAll(win)	WindowPtr	win;	{	int	i;		for (i = 0; i < nbag; i++)		{		MagBagShow(i, win);		}	}	MagPick()	{	register Byte	*bp;	register int	i, j;	register int	nextLine = 64*((200-16)/3-1);	register int	nextPix	= ((200-16)/8)/3;		bp = maginfo.dest;	for (i = 0; i < 3; i++, bp += nextLine - nextPix*3)		for (j = 0; j < 3; j++, bp += nextPix)			if (*bp > 0)				return ((i*3) + j);	return (-1);	}	MagCopy(win)	WindowPtr	win;	{	Rect	r;	Rect	rd;	WindowPtr	owin;	#ifdef FAST	return;#endif	GetPort(&owin);		SetPort(win);		rd = win->portRect;	rd.bottom -= 16;	rd.right -= 16;	LocalToGlobal(&rd.top);	LocalToGlobal(&rd.bottom);		r.top = 0;	r.left = 0;	r.bottom = (rd.bottom - rd.top);	r.right = (rd.right - rd.left);	if (r.right < maginfo.nfields*12)		{		r.right = maginfo.nfields*12;		r.bottom = maginfo.nlines*2;		}		CopyBits(&maginfo.bits, &screenBits, &r, &rd, srcCopy, 0L);		SetPort(owin);	}MagStripOffset(n)	{	if (n < 1) n = 1;		maginfo.stripOffset = n;	return (n);	}	MagNfields(n)	{	maginfo.nfields = n;	return (n);	}	MagNlines(n)	{	if (n > MaxLine)		return (-1);	maginfo.nlines = n;	return (n);	}	MagStartLine(n)	{	maginfo.startLine = n;	return (n);	}	MagHigh(n)	{	maginfo.highCut = n&0xff;	return (n);	}	MagLow(n)	{	maginfo.lowCut = n&0xff;	return (n);	}	/* ------------------------------------------------------------------- *//*Honey dear, she called to me.We japanese do not have these honey words.Sing to me Sade's smooth operator.You never call. I know.*/#define SccRbase	0x9FFFF8#define SccWbase	0xBFFFF9#define aData		6#define aCtl		2#define bData		4#define bCtl		0#if 1Byte	INSCC[] = { 4, 4, 11, 0x28, 14, 0, 3, 0xC1, 5, 0x6A, 0x30, 0 };#define INSCClen	11#elseByte	INSCC[] = { 4, 4, 11, 0x28, 14, 0, 3, 0xC1, 5, 0x6A, 0x30, 15, 8, 0 };#define INSCClen	13#endifByte	*SWdata, *SWctl, *SRdata, *SRctl;MagPortA()	{	asm		{		lea		SWdata,a0		move.l	#SccWbase+aData,(a0)+		move.l	#SccWbase+aCtl,(a0)+		move.l	#SccRbase+aData,(a0)+		move.l	#SccRbase+aCtl,(a0)+		}	}	MagPortB()	{	asm		{		lea		SWdata,a0		move.l	#SccWbase+bData,(a0)+		move.l	#SccWbase+bCtl,(a0)+		move.l	#SccRbase+bData,(a0)+		move.l	#SccRbase+bCtl,(a0)+		}	}	MagSccInit()	{		asm		{		move.l	SWctl,a1		lea		INSCC,a0		moveq	#INSCClen-1,d0in1:	move.b	(a0)+,(a1)		dbf		d0, @in1		}	}	MagWrite1(ch)	{	register int 	to = 0x7FFF;	register Byte	*ctl = SRctl;		while (--to > 0 && !(*ctl & 0x04) );		if (to > 0)		{		*SWdata = ch;		return (1);		}	return (0);	}	MagRead1()	{	register int 	to = 0x7FFF;	register Byte	*ctl = SRctl;		while (--to > 0 && !(*ctl & 0x01) );		if (to > 0)		{		return ( *SRdata );		}		return (-1);	}	MagHreset()	{	asm		{		move	SR,-(sp)		ori		#0700,SR		;disable interrupts		move.l	SWctl,a0		move.b	#5,(a0)		move.b	#0x7A,(a0)	;send break		move.w	#17,d0	@1	dbf		d0,@1		move.b	#5,(a0)		;		move.b	#0x6A,(a0)	;remove break		move	(sp)+,SR		;enable interrupts again		}	}static MagGrab1(arg)	{	asm		{; TRANSFER A PICTURE INTO THE MAC for reading pictures whose  horz. size is ;				  not divisible by 3 i.e. 512 wide; reads in D3 fields at 3 bytes/swipe and then 1 more 8 bit swipe;; D1=COMP & odd/even FLAG	;D3= # OF FIELDS; D2=INITIAL STRIPE 		;D4= # OF LINES; D5= # of lines to delay down till picture starts; D6= High and Low Cut Value; A0= address to put data into	movem.l	a0-a6/d1-d7,-(sp)			MOVE	SR,-(SP)	ORI		#0x0700,SR		;KILL INTERRUPTS		move.w	maginfo.oddComp,d1	move.w	maginfo.stripOffset,d2	move.w	maginfo.nfields,d3	move.w	maginfo.nlines,d4	move.w	maginfo.startLine,d5	move.l	maginfo.highCut,d6	move.l	maginfo.dest,a0		move.w	d6,d0		;get low cut	jsr		@setlow	bne		@Gtmout1		swap	d6	move.w	d6,d0	jsr		@sethi		;set high cut	bne		@Gtmout1	lea		SWdata(a5),a1	;get address of list of Scc addresses	move.l	(a1)+,a4		;get Scc Register Addresses	move.l	(a1)+,a3	move.l	(a1)+,a2	move.l	(a1)+,a1	/*ADD.w	MvHorVal(a5),d2	;center screen*/	MOVE.W	D4,D6		;GET # OF LINES/FIELD	ADD.W	D6,D6		;DOUBLE FOR LINES/FRAME	SUBQ.W	#1,D6		;LINES -1	MOVE.W	#-128,A6		;	LSL.W	#6,D6		;*64 = ADDRESS BACKUP AT BOTTOM  OF FRAME		move.b	(a2),d0		;	move.b	(a2),d0	move.b	(a2),d0	move.b	(a2),d0		;clean out SCC		MOVE.B	#0xA4,D0		;SEND PICTURE COMMAND	JSR		@OUTCHR	bne		@Gtmout		;timout error		MOVE.B	D2,D0		;INITIAL STRIPE 1	JSR		@OUTCHR	bne		@Gtmout		addq.w	#2,d3		;tell em 1 more for last 1 byte swipe	MOVE.B	D3,D0		;# OF FIELDS 2	JSR		@OUTCHR	bne		@Gtmout		subq.w	#2,d3		;	LSR.W	#1,D3		;MAKE FRAMES	SUBQ.W	#1,D3		;MAKE DBF D3,XXX VALUE	MOVE.B	D4,D0		;# OF LINES 3	JSR		@OUTCHR	bne		@Gtmout		move.b	d5,d0		;delay down 4	JSR		@OUTCHR	bne		@Gtmout		SUBQ.W #1,D4		;MAKE DBF COUNTERGETS1:	move.l	(sp),(sp)	;time delay	btst.b	#2,(a1)	beq		@GETS1		;	move.b	d1,(a4)		;send COMPLEMENT FLAG 5G0:		MOVE.W	#2-1,D0		;2 FIELDSG0A:		MOVE.W	D4,D2		;ONE FIELD LINE COUNTGOB:		move.w	#3-1,d7		;	move.l	#0x20000,d1	;timout constantG1:	subq.l	#1,d1		;count down timout	beq		@Gtmout		;timout		BTST.B	#0,(A1)		;CHAR READY?	BEQ		@G1			;NO		MOVE.B	(A2),(A0)+	;GET DATA BYTE	DBF		D7,@G1		ADDA	#128,A0		;SKIP A LINE	SUBA.W	#3,A0	DBF		D2,@GOB		;FOR 1 FIELD		SUBA.W	D6,A0		;BACKUP TO DO NEXT FIELD	DBF		D0,@G0A		;FOR FRAME		ADDA.W	A6,A0		;STEP OVER NUMBER OF BYTES WE TOOK	ADDA.W	#3,A0		; 	DBF		D3,@G0		;COUNT DOWN FRAMES	; now do last 1 byte swipe	GL0:	MOVE.W	#2-1,D0		;2 FIELDSGL0A:	MOVE.W	D4,D2		;ONE FIELD LINE COUNTGLOB:				move.l	#0x20000,d1	;timout constantGL1:		subq.l	#1,d1		;count down timout	beq		@Gtmout		;timout	BTST.B	#0,(A1)		;CHAR READY?	BEQ		@GL1			;NO		MOVE.B	(A2),(A0)+	;GET DATA BYTE	move.l	#0x20000,d1	;timout constantGL2:	subq.l	#1,d1		;count down timout	beq		@Gtmout		;timout	BTST.B	#0,(A1)		;CHAR READY?	BEQ		@GL2			;NO	MOVE.B	(A2),D5		;TAKE DATA BYTE BUT DON'T USE IT	move.l	#0x20000,d1	;timout constantGL3:	subq.l	#1,d1		;count down timout	beq		@Gtmout		;timout	BTST.B	#0,(A1)		;CHAR READY?	BEQ		@GL3			;NO	MOVE.B	(A2),D5		;TAKE DATA BYTE BUT IGNORE IT	ADDA.W	#128-1,A0	;SKIP A LINE	DBF		D2,@GLOB		;FOR 1 FIELD		SUBA.W	D6,A0		;BACKUP TO DO NEXT FIELD	DBF		D0,@GL0A		;FOR each Field		/* ----- all done ------- */		clr.w	d0		;no errorxreturn:	MOVE	(SP)+,SR	movem.l	(sp)+,a0-a6/d1-d7	return	Gtmout:Gtmout0:	_ShowCursor		;no	move.w	#1,d0		;timout error	goto	xreturn	Gtmout1:	bra		@Gtmout0;	set the high cut valuesethi:seth1:	swap	d0	move.b	#0xA0,d0	bra.s	@setl1	;	set the low cut valuesetlow:	swap	d0	move.b	#0xA2,d0	;command codesetl1:		jsr		@OUTCHR	bne		@setl2	swap	d0	jsr		@OUTCHRsetl2:	rts	OUTCHR:	move.l	SRctl(a5),a1	move.l	SWdata(a5),a4	move.w	d0,-(sp)	move.w	#0x8000,d0outc1:	subq.w	#1,d0		;timeout countdown	beq		@outcerr	btst.b	#2,(a1)	beq		@outc1		;	move.w	(sp)+,d0	move.b	d0,(a4)		;send char	move.l	d0,-(sp)		;	move.w	#50,d0outc2:	dbf		d0,@outc2		;wait for poor z-80	move.l	(sp)+,d0	ori		#0x4,CCR		;set zero flagoutc3:	rts	outcerr:	move.w	(sp)+,d0outc4:	andi	#0x0FB,CCR		;set non-zero	rts		}	}		