/**/#include <Quickdraw.h>#include <ResourceMgr.h>#include <pascal.h>#include <stdio.h>#include "pioneer.h"#include "qDef.h"#include "qMacDef.h"#include "MagInfo.h"#include "vdisc.h"extern char 	qtrace;#define TRACE(a,b) if (qtrace>=a) printf bextern short	usedig;useDig()	{	usedig = 1;	}	useKey()	{	usedig = 0;	}	/* ---------------- setaud ---------------------------------------------*//* Enable audio from video deck, 0=off, 3=stereo on*/setaud(n)	{	extern int audon;		audon = n;	}	doexit()	{	ExitToShell();	}	vplay()	{	z(PLAY,0);	}vpos()	{	return ( z(POS,0) );	}	vsearch(n)	{	z(SEARCH,n);	z(SEARCHWAIT,0);	}	vstop()	{	z(STOP,0);	}	vaudio(n)	{	z(AUDIO,n);	}		int		MagWrite1(), MagRead1(), MagHreset(), MagGrab(), MagInit();int		MagStripOffset(), MagNfields(), MagNlines(), MagStartLine();int		MagHigh(), MagLow(), MagPick();qItem	imagget(), Sumxy(), DisplaySum(), setdiff();qItem	lpick(), rpick(), sumprint();qItem	ipiano();int		MagBagAlloc(), MagBagGrab();qItem	imagbagshow(), imagshowall(), psend(), pread(), pinit();int		macen(), eport();qIfunc ldvFuncs[] ={	{ useDig, "usedig", 0 + qRetInt },	{ useKey, "usekey", 0 + qRetInt },	{ vstop, "vstop", 0 + qRetInt },	{ vsearch, "vsearch", 1 + qCint1 + qRetInt },	{ vaudio, "vaudio", 1 + qCint1 + qRetInt },	{ vpos, "vpos", 0 + qRetInt },	{ vplay, "vplay", 0 + qRetInt },	{ setaud, "setaud", 1 + qCint1 + qRetInt },	{ MagBagAlloc, "mballoc", 1 + qCint1 + qRetInt },	{ MagBagGrab, "mbgrab", 0 + qRetInt },	{ imagbagshow, "mbshow", 2 },	{ imagshowall, "mbshowall", 1 },	{ ipiano, "piano", 0 },	{ MagWrite1, "mwrite", 1 + qCint1 + qRetInt },	{ MagRead1, "mread", 0 + qRetInt },	{ MagInit, "minit", 0 + qRetInt },	{ MagHreset, "mreset", 0 + qRetInt },	{ MagGrab, "mgrab", 0 + qRetInt },	{ MagStripOffset, "moffset", 1 + qCint1 + qRetInt },	{ MagNfields, "mnfields", 1 + qCint1 + qRetInt },	{ MagNlines, "mnlines", 1 + qCint1 + qRetInt },	{ MagStartLine, "mstart", 1 + qCint1 + qRetInt },	{ MagHigh, "mhigh", 1 + qCint1 + qRetInt },	{ MagLow, "mlow", 1 + qCint1 + qRetInt },	{ imagget, "mget", 1 },	{ MagPick, "mpick", 0 + qRetInt },	{ Sumxy, "sumxy", 0 },	{ DisplaySum, "dispsum", 1 },	{ setdiff, "setdiff", 1 },	{ lpick, "lpick", 0 },	{ rpick, "rpick", 0 },	{ sumprint, "sumprint", 0 },	{ macen, "macen", 1 + qCint1 + qRetInt },	{ eport, "eport", 1 + qCint1 + qRetInt },	{ psend, "psend", 1 },	{ pread, "pread", 0 },	{ pinit, "pinit", 0 },	{ doexit, "``", 0 },		{ 0, 0, 0 }};	static Handle macen_h;static void (*macen_f)();OpenMacEnhancer()	{	int	val;		val = OpenResFile("\pMacEnhancer");	if (val < 0)		printf("Open MacEnhancer =%d\n",val);			macen_h = GetResource('PACK', -4096);	if (! macen_h)		{		printf("GetResource failed\n");		macen_f = 0L;		return;		}			HLock(macen_h);		macen_f = (void (*)()) (*macen_h);#if 0	printf("macen_h=%lx fp=%#lx\n", macen_h, macen_f);#endif	}	macen(op)	int	op;	{	int	val;		if (! macen_f)		return (0);		val = CallPascalW(18, -1, 0L, 0L, 0L, (int)op, 1/*-Modem-*/, macen_f);		return (Numify(val));	}	eport(n)	{	if (n == 2) n = 0xCF;	else if (n == 3) n = 0x8F;	else n = 0x6F;	return (macen(n));	}	qItem	imagget(wo)	Wino	*wo;	{	if (Type(wo) != qIstructType ||		wo->type != qWinoSubType)		{		printf("imagget: not wino %lx\n",wo);		return (NIL);		}	MagCopy(wo->window);	return (NIL);	}	qItem	imagbagshow(n, wo)	long	n;	Wino	*wo;	{	if (Type(wo) != qIstructType ||		wo->type != qWinoSubType)		{		printf("imagbagshow: not wino %lx\n",wo);		return (NIL);		}	MagBagShow((int)n, wo->window);	return(NIL);	}qItem	imagshowall(wo)	Wino	*wo;	{	if (Type(wo) != qIstructType ||		wo->type != qWinoSubType)		{		printf("imagshowall: not wino %lx\n",wo);		return (NIL);		}	MagShowAll(wo->window);	return(NIL);	}/* -------------------------------------------------------------------- */#define MaxSumL2	4#define MaxSum		(1<<MaxSumL2)#define TRESH		10#define ScanLine	64typedef struct AxeSum	{	int		lpick;	int		rpick;	int		range;	int		tresh;	int		sum[MaxSum];	}	AxeSum;	int		sums[MaxSum][MaxSum];#define XDIFF	(&asum[4])#define YDIFF	(&asum[5])AxeSum	asum[6];AxeSum	*xsum = &asum[0];AxeSum	*ysum = &asum[1];AxeSum	*xsee = XDIFF;AxeSum	*ysee = YDIFF;int		axeI = 0;int		dodiff = 0;extern MagInfo	maginfo;extern Byte		bitCount[];qItem Sumxy()	{	int					xlen, ylen;	int					nx, ny;	register int		i, j;	register int		ii, jj;	register AxeSum		*sp;	register Byte		*bp0, *bp;	int					*sump0, *sump;	AxeSum				*oxsum, *oysum;		xlen = (maginfo.nfields*3)>>1;	ylen = maginfo.nlines*2;		nx = (xlen+MaxSum-1) >> MaxSumL2;	ny = (ylen+MaxSum-1) >> MaxSumL2;		TRACE(1,("xlen=%d ylen=%d nx=%d ny=%d\n",xlen, ylen, nx,ny));				for (j = MaxSum-1; j >= 0; j--)		for (i = MaxSum-1; i >= 0; i--)			sums[j][i] = 0;				sump0 = &sums[0][0];	bp0 = (Byte *)maginfo.bits.baseAddr;	for (jj = 0; jj < ylen; 			jj += ny, sump0 += MaxSum)		{		for (j = 0; j < ny; j++, bp0 += ScanLine)			{			bp = bp0;			sump = sump0;				for (ii = 0; ii < xlen; ii += nx, sump++)				{				for (i = 0; i < nx; i++, bp++)					{					*sump += bitCount[*bp];					}				}			}		}		#if 0	for (j = 0; j < MaxSum; j++)		{		for (i = 0; i < MaxSum; i++)			printf(" %d", sums[j][i]);		printf("\n");		}#endif	oxsum = xsum;	oysum = ysum;	axeI += 2;	if (axeI > 2) axeI = 0;		xsum = &asum[axeI];	ysum = &asum[axeI+1];	for (i = MaxSum-1; i >= 0; i--)		{		xsum->sum[i] = ysum->sum[i] = 0;		}	for (sump = &sums[0][0], j = 0; 			j < MaxSum; j++, sump += MaxSum)		{		for (i = MaxSum-1; i >= 0; i--)			{			ii = sump[i];			xsum->sum[i] += ii;			ysum->sum[j] += ii;			}		}			if (! dodiff)		{		xsee = xsum;		ysee = ysum;		}	else 		{		xsee = XDIFF;		ysee = YDIFF;		for (i = MaxSum-1; i >= 0; i--)			{			xsee->sum[i] = xsum->sum[i] - oxsum->sum[i];			ysee->sum[i] = ysum->sum[i] - oysum->sum[i];			}		}		xsee->range = (ylen<<3)*nx;	xsee->tresh = xsee->range/TRESH;		ysee->range = (xlen<<3)*ny;	ysee->tresh = ysee->range/TRESH;	#if 0	/* find left and right pos. > 10% */	xsee->lpick = -1;	xsee->rpick = -1;	for (i = 0; i < MaxSum; i++)		{		ii = xsee->sum[i];		if (ii > xsee->tresh)			{			xsee->rpick = i;			if (xsee->lpick < 0)				{				xsee->lpick = i;				}			}		}#endif	/* Find maximum point */	xsee->lpick = -1;	ii = xsee->tresh;	for (i = 0; i < MaxSum; i++)		{		jj = xsee->sum[i];		if (jj > ii)			{			xsee->lpick = i;			ii = jj;			}		}			return (NIL);	}static qItem sumprint()	{	int	xlen, ylen, nx, ny;	int	i;		xlen = (maginfo.nfields*3)>>1;	ylen = maginfo.nlines*2;		nx = (xlen+MaxSum-1) >> MaxSumL2;	ny = (ylen+MaxSum-1) >> MaxSumL2;		printf("xlen=%d ylen=%d nx=%d ny=%d\n",xlen, ylen, nx,ny);	printf("xrange=%d yrange=%d\n",xsee->range, ysee->range);	printf("xtresh=%d ytresh=%d\n",xsee->tresh,ysee->tresh);	printf("lpick=%d rpick=%d\n",xsee->lpick,xsee->rpick);		printf(" -x- ");	for (i = 0; i < MaxSum; i++)		printf(" %d", xsee->sum[i]);	printf("\n -y- ");	for (i = 0; i < MaxSum; i++)		printf(" %d", ysee->sum[i]);	printf("\n");	return (NIL);	}static qItem setdiff(a)	long	a;	{	dodiff = a;	return ((qItem) a);	}	static qItem	lpick()	{	return (Numify(xsee->lpick));	}/* return pick value between 0 ... 11 */thePick()	{	return (xsee->lpick );	} 	static qItem	rpick()	{	return (Numify(ysee->rpick));	}	qItem DisplaySum(wo)	Wino	*wo;	{			WindowPtr	w;	int			xlen, ylen;	Rect		rd;	WindowPtr	ow;	int			c, d, i, max, scale;		if (Type(wo) != qIstructType ||		wo->type != qWinoSubType)		{		printf("DisplaySum: not wino %lx\n",wo);		return (NIL);		}			w = wo->window;	rd = w->portRect;	ylen = (rd.bottom - rd.top);	xlen = (rd.right - rd.left);		GetPort(&ow);	SetPort(w);		EraseRect(&rd);		scale = (xsee->range/ylen)*2;	if (scale < 1) scale = 1;	/* X sum on y-axis */		d = xlen/MaxSum;	if (d <= 0) d = 1;	MoveTo(0, ylen/2);	PenPat(black);	for (c = d-1, i = 0; i < MaxSum; i++, c += d)		{		LineTo(c, ylen/2 - xsee->sum[i]/scale);		}	scale = (ysee->range/xlen)*2;	if (scale < 1) scale = 1;	/* Y sums on x-axis */		d = ylen/MaxSum;	if (d <= 0) d = 1;	MoveTo(xlen/2, 0);	PenPat(gray);	for (c = d-1, i = 0; i < MaxSum; i++, c += d)		{		LineTo(xlen/2 + ysee->sum[i]/scale, c);		}			SetPort(ow);			return (NIL);	}/* -------------------------------------------------------------------- */#include <EventMgr.h>qItem	ipiano()	{	SetEventMask(everyEvent);		z(CHARGEN,0);		while (pianoLoop());		return (NIL);	}static unsigned int	startPos, stopPos;static int		keyPress = 0;static int		octave = 0;static	pianoLoop()	{	EventRecord	myEvent;	int			mr;	unsigned int		pos;		SystemTask();	if (GetNextEvent(everyEvent, &myEvent) == FALSE)		{		pos = z(POS,0);		if (keyPress				&& (pos < startPos || pos >= stopPos) )			{			z(SEARCH,startPos);			z(SEARCHWAIT,0);			z(STOPAT,stopPos);			}		return (1);		}		mr = 1;	switch (myEvent.what) 		{		case mouseDown:			mr = 0;			break;		case keyDown:			PianoKeyDown((int) (myEvent.message & charCodeMask));			break;		case keyUp:			PianoKeyUp((int) (myEvent.message & charCodeMask));			break;		default:			break;		}	return ( mr );	}	static int keyMap[] = 	{	'1', '2', '3', '4', '5', '6', '7',	 	'q', 'w', 'e', 'r', 't', 'y', 'u',	 	'a', 's', 'd', 'f', 'g', 'h', 'j',	 	'z', 'x', 'c', 'v', 'b', 'n', 'm'	 };		static PianoKeyDown(ky)	{	int i, key, shift = 0;	#if 0	printf("%c",ky);#endif	if (ky >= 'A' && ky <= 'Z')		{		ky = ky - 'A' + 'a';		shift = 1;		}			keyPress = 0;	for (i = 0; i < 28; i++)		if (keyMap[i] == ky) 			{			keyPress = 1;			octave = i/7 + 4*shift;			if (octave > 6) octave = 6;			key = i % 7;			break;			}				if (! keyPress)		{		startPos = ((unsigned)Random()) % 54000L;		stopPos = startPos + 30;		keyPress = 1;		return;		}			startPos = key*60L + 426L*octave + 31195L;	stopPos = startPos + 59L;#if 0	printf(" key=%d oct=%d start=%u stop=%u\n",				key,octave,startPos, stopPos);#endif	z(SEARCH,startPos);	z(SEARCHWAIT,0);	z(STOPAT,stopPos);	}	static PianoKeyUp(ky)	{	keyPress = 0;#if 0	z(STOP,0);#endif	}	/* ------------------------------------------------------------------- */#include <ToolboxUtil.h>Cursor	waitCursor;SetupCursors()	{	CursHandle	hcurs;		hcurs = GetCursor(watchCursor);	waitCursor = **hcurs;	}/* ------------------------------------------------------------------- */#include <SerialDvr.h>static pvd = AoutRefNum;#define PPort sPortAPionOpen(port)	{	int vd;	int vRefNum = 0;	int serConfig = baud4800 + stop10 + noParity + data8;	int er;		er = RAMSDOpen(PPort);	if (er) OhShit("Er=%d on RAMSopen\n", er);	er = SerReset(pvd, serConfig);	if (er) OhShit("er=%d on serreset of output\n", er);	er = SerReset(pvd + 1, serConfig);	if (er) OhShit("er=%d on serreset of input\n", er);	}	qItem	psend(str)	qSymbol	*str;	{	Byte	*sp = str->name;	long	count;	int		er;	Byte	ch;		printf("%d %s\n", str->name[0], str->name+1);		count = str->name[0];	er = FSWrite(pvd, &count, str->name+1);	if (er) OhShit("er=%d on psend\n", er);		count = 1;	ch = 0x0D;	er = FSWrite(pvd, &count, &ch);		return (NIL);	}qItem	pread()	{	Byte	buf[128];	long	count = 128;		SerGetBuf(pvd + 1, &count);	if (count < 1) return (NIL);		FSRead(pvd + 1, &count, buf);	if (count > 0)		{		buf[count] = 0;		printf("[%ld]\n%s\n",count, buf);		}			return (NIL);	}	qItem	pinit()	{	PionOpen();	return (NIL);	}			