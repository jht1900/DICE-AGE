/**/#include "qDef.h"extern char qtrace;#define TRACE(a,b) if (qtrace>=a) printf bqItem	Eval(ev, it)	Env			*ev;	qItem		it;	{	qSymbol		*sy;	qItem		vl = NIL;	register qList		*lp;	register qList		*al;				TRACE(2,("Eval: ev=%lx it=%lx\n",ev,it));		if (Symbolp(it))		{		return ( (qItem) ((qSymbol *)it)->val );		}			if (! Listp(it))		{		return (it);		}			sy = (qSymbol *)Car(it);	lp = Cdr(it);	TRACE(2,("\t sy=%lx cdr=%lx\n", sy, lp));		if (Symbolp(sy))		{		qIfunc				*fv;				fv = (qIfunc *)sy->func;		if (Type(fv) == qIfuncType && ( fv->argDesc & qNoEval))			{			return (ApplyIfunc(ev, fv, lp));			}		}			for (al = (qList *)NIL; 			Listp(lp) ; lp = Cdr(lp) )		{					al = Cons(ev, Eval(ev, Car(lp)), al);		}	al = Nreverse(al);	TRACE(2,(" arglist=%lx len=%ld\n", al, Length(al)));		vl = Apply(ev, sy, al);		FreeList(ev, al);		return (vl);	}	qItem	Apply(ev, fp1, al)	Env			*ev;	qItem		fp1;	qList		*al;	{	register qItem	fp;		TRACE(2,("Apply: ev=%lx fp=%lx al=%lx\n",ev,fp,al));		if (Symbolp(fp1))		fp = ((qSymbol *)fp1)->func;	else		fp = fp1;			if (Listp(fp))		return ( ApplyDefun(ev, fp, al) );	if (Type(fp) == qIfuncType)		return ( ApplyIfunc(ev, fp, al) );			if (Symbolp(fp1))		printf("Can't apply %s\n", ((qSymbol *)fp1)->name + 1);	else		printf("Can't apply %lx\n", fp);		return ( fp );	}	qItem	ApplyDefun(ev, fp, al)	Env				*ev;	register qList	*fp;	qList			*al;	{	qItem		vl, Progn();	qItem		argNames;		TRACE(2,("ApplyDefun: ev=%lx fp=%lx al=%lx\n",ev,fp,al));		if (! Listp(fp))		{		printf("Null body fp=%lx\n", fp);		return ( NIL );		}			argNames = Car(fp);		PushArgs(ev, argNames, al);		vl = Progn(ev, Cdr(fp));		PopArgs(ev, argNames);		return (vl);	}	qItem	Progn(ev, lp)	Env		*ev;	register qList	*lp;	{	qItem	vl = NIL;		for (; Listp(lp); lp = Cdr(lp))		{		vl = Eval(ev, Car(lp));		}	return (vl);	}	PushArgs(ev, argNames, argVals)	register Env	*ev;	qList			*argNames;	qList			*argVals;	{	register qList	*oldVals;	qSymbol			*sy;		/* Make list of values of symbols in argNames and push onto estack	*/	for (oldVals = (qList *)NIL; 			Listp(argNames); argNames = Cdr(argNames))		{		sy = (qSymbol *) Car(argNames);		if (! Symbolp(sy))			{			printf("Non-symbol in arg-list =%lx\n",sy);			continue;			}		oldVals = Cons(ev, sy->val, oldVals);		if (Listp(argVals))			{			sy->val = Car(argVals);			argVals = Cdr(argVals);			}		else {			/* prog also call's us */			/* printf("Too few args to func arg=%s\n",sy->name+1); */			sy->val = NIL;			}		}	oldVals = Nreverse(oldVals);	ev->eStack = Cons(ev, oldVals, ev->eStack);	}	PopArgs(ev, argNames)	register Env	*ev;	qList			*argNames;	{	register qList	*oldVals;	qSymbol			*sy;		/* Assign old values on e stack to symbols in argNames */		for (oldVals = (qList *) Car(ev->eStack);			Listp(oldVals) && Listp(argNames); 			oldVals = Cdr(oldVals), argNames = Cdr(argNames))		{		sy = (qSymbol *) Car(argNames);		if (! Symbolp(sy))			continue;		sy->val = Car(oldVals);		}	/* Free old value list */	oldVals = ev->eStack;	ev->eStack = Cdr(oldVals);	Rplacd(oldVals, Car(oldVals));	FreeList(ev, oldVals);	}	qItem	ApplyIfunc(ev, fp, al)	Env				*ev;	qIfunc			*fp;	register qList	*al;	{	unsigned long	ad, arg, cint;	int				n, convNum;	qItem			vl;	short			a[16];	register int	i;				TRACE(2,("ApplyIfunc: ev=%lx fp=%lx al=%lx\n",ev,fp,al));		ad = fp->argDesc;	n = ad & qNargsMask;	cint = ad >> qNargsBitLen;	convNum = (ad & qConvNum) != 0;	if (ad & qNoEval)		{		return ((*fp->func)(ev, al));		}	if (ad & qVarArg)		{		return ((*fp->func)(ev, al));		}			i = 0;	if (ad & qEnvArg)		{		a[0] = ((unsigned long) ev) >> 16;		a[1] = ((unsigned long) ev) & 0xFFFF;		i += 2;		}	for (; n > 0; n--, al = Cdr(al), cint >>= 1)		{		if (Listp(al))			{			arg = (long) Car(al);						}		else {			printf("Too few args to %s\n", fp->name);			arg = (long) NIL;			}					if (cint & 1)			{			a[i] = arg;			i += 1;			}		else {			if (convNum && Nump(arg))				arg = Cnum(arg);			a[i] = arg >> 16;			a[i+1] = arg & 0xFFFF;						i += 2;			}		}	switch (i)		{		case 0:			vl = (*fp->func)();			break;		case 1:			vl = (*fp->func)(a[0]);			break;		case 2:			vl = (*fp->func)(a[0], a[1]);			break;		case 3:			vl = (*fp->func)(a[0], a[1], a[2]);			break;		case 4:			vl = (*fp->func)(a[0], a[1], a[2], a[3]);			break;		case 5:			vl = (*fp->func)(a[0], a[1], a[2], a[3], a[4]);			break;		case 6:			vl = (*fp->func)(a[0], a[1], a[2], a[3], a[4], a[5]);			break;		case 7:			vl = (*fp->func)(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);			break;		case 8:			vl = (*fp->func)(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);			break;		default:			vl = (*fp->func)(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7],						a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);			break;		}			if (ad & qRetInt)		{		vl = (int)vl;		vl = Numify(vl);		}	else if (ad & qRetLong)		{		vl = Numify(vl);		}			return (vl);	}	int		Nargs(it)	qIfunc	*it;	{	if (Type(it) == qIfuncType)		return ( it->argDesc & qNargsMask );			if (! Listp(it))		return (-1);			return ( Length(Car(it)) );	}qItem	Mapcan(ev, func, lp)	Env				*ev;	qItem			*func;	register qList	*lp;	{	register qList	*rp;	qList			*Nconc();		for (rp = (qList *)NIL; Listp(lp); lp = Cdr(lp))		{		rp = Nconc( Apply(ev, func, lp), rp);		}	rp = Nreverse(rp);		return ((qItem) rp);	}	qItem	Set(sy, vl)	qSymbol	*sy;	qItem	vl;	{	if (! Symbolp(sy))		{		printf("Can't set non-symbol %lx\n", sy);		return (NIL);		}	sy->val = vl;	return (vl);	}			