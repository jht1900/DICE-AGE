/**/#include <EventMgr.h>#include <DialogMgr.h>#include <ControlMgr.h>#include "qDef.h"#include "qMacDef.h"extern char qtrace;#define TRACE(a,b) if (qtrace>=a) printf bqItem irandom(), itickcount(), ibutton(), ireadch(), idelay();qItem iwino(), ishow(), isetval(), ihideWino(), ishowWino(), iselectWino();qIfunc qPrimMacIfunc[] =	{	{ irandom, "random", 0 + qRetInt },	{ itickcount, "tick-count", 0 },	{ ibutton, "buttonp", 0 },	{ ireadch, "readch", 0 },	{ idelay, "delay", 1 },	{ iwino, "wino", 0 + qVarArg + qEnvArg	},	{ ishow, "show", 2 + qEnvArg },	{ isetval, "set-val", 3 + qEnvArg },	{ ihideWino, "hide-wino", 1 },	{ ishowWino, "show-wino", 1 },	{ iselectWino, "select-wino", 1 },		{ 0, 0, 0 }	};	/* ------------------------------------------------------------------- */qItem	idelay(v)	long	v;	{	long	tc;		Delay(v, &tc);	return (Numify(tc));	}qItem	ireadch()	{	EventRecord	evt;		if (GetNextEvent(keyDownMask, &evt)			&& evt.what == keyDown || evt.what == autoKey)		{		return (Numify(evt.message & charCodeMask) );		}	return (NIL);	}static qItem	irandom()	{	return ( Numify(Random()) );	}	static qItem	ibutton()	{	extern qItem	trueSym;		if (Button())		return (trueSym);	return (NIL);	}	static qItem	itickcount()	{	return ( Numify(TickCount()) );	}	/* -------------------------------------------------------------------- */static qItem	iwino(ev, argList)	Env		*ev;	qList	*argList;	{	qList	*itemList = (qList *)NIL;	qSymbol	*title = (qSymbol *)InternSymbol(ev,"\1t");	long	wide = 100;	long	high = 100;	long	hpos = 3;	long	vpos = 40;	qItem	buttonSym = InternSymbol(ev,"\06button");	qItem	radioSym = InternSymbol(ev, "\05radio");	qItem	vsliderSym = InternSymbol(ev,"\07vslider");	qItem	hsliderSym = InternSymbol(ev,"\07hslider");		Rect			wrect;	Rect			brect;	int				nwi;	Wino			*wo;	WinoItem		*wi;	qList			*lp;	#define ButVmax		20#define ButHmax		60#define ButMargin	3	static int		first = 1;	TRACE(1,("iwino: ev=%lx arglist=%lx\n",ev, argList));	if (first)		{		first = 0;		MoveWindow(FrontWindow(), 204, 198, false);		SizeWindow(FrontWindow(), 512-204, 330-198, TRUE);		}			SetList(argList, &itemList, &title, &wide, &high, &hpos, &vpos, NULL);		if (! Symbolp(title))		{		printf("menu: title no symbol %lx\n",title);		return (NIL);		}			nwi = Length(itemList);		wo = (Wino *)NewPtr( (long) sizeof(Wino) + nwi * sizeof(WinoItem));	if (wo == NULL) OhShit(1,"iwino: alloc failed\n");	wo = (Wino *) qPtr(wo, qIstructType);		wo->type = qWinoSubType;	wo->nitems = nwi;		wrect.left = hpos;	wrect.top = vpos;	wrect.right = hpos + wide;	wrect.bottom = vpos + high;		wo->window = NewWindow(NULL, &wrect, title->name, TRUE, 						documentProc, -1, TRUE, 0L);	brect.top = wo->window->portRect.top + ButMargin;	brect.left = wo->window->portRect.left + ButMargin;	brect.bottom = brect.top + ButVmax;	brect.right = brect.left + ButHmax;		wi = &wo->witems[0];	for (lp = itemList; Listp(lp); lp = Cdr(lp), wi++)		{		register qItem	it;		register qItem	ty;		Rect			rect;				wi->type = -1;				it = Car(lp);		if (! Listp(it))			{			printf("menu: bad control %lx\n", it);			continue;			}					ty = Car(it);		it = (qItem) Cdr(it);				if (ty == buttonSym || ty == radioSym)			{			/* Push button control */			qSymbol	*name = (qSymbol *)NIL;			qItem	func = NIL;			long	charCode = -1;						SetList(it, &name, &func, &charCode, NULL);			if (! Symbolp(name))				{				printf("menu: bad button name %lx\n",name);				continue;				}						wi->control = NewControl(wo->window, &brect, name->name, TRUE, 								0, 0, 1, 								(ty==buttonSym)? pushButProc: radioButProc, 0L);											wi->type = pushButProc;									wi->func = func;			wi->charCode = charCode;						OffsetRect(&brect, ButHmax + ButMargin, 0);			if (brect.right >= wo->window->portRect.right)				{				OffsetRect(&brect, 0, ButVmax + ButMargin);				brect.left = wo->window->portRect.left + ButMargin;				brect.right = brect.left + ButHmax;				}				}		else if (ty == vsliderSym)			{			/* Vertical Slider */						long	max = 256;			qItem	updateFunc = NIL;						SetList(it, &max, &updateFunc, NULL);						rect = wo->window->portRect;			rect.left = rect.right - SBarWidth;			rect.right += 1;			rect.bottom -= (SBarWidth-1);			rect.top -= 1;						wi->control = NewControl(wo->window, &rect, "\p", TRUE, 								0, 0, (int)max, scrollBarProc, 0L);											wi->type = scrollBarProc;									wi->func = updateFunc;			wi->charCode = -1;			}		else if (ty == hsliderSym)			{			/* Horizontal Slider */						long	max = 256;			qItem	updateFunc = NIL;						SetList(it, &max, &updateFunc, NULL);						rect = wo->window->portRect;			rect.top = rect.bottom - SBarWidth;			rect.right -= (SBarWidth-1);			rect.bottom += 1;						wi->control = NewControl(wo->window, &rect, "\p", TRUE, 								0, 0, (int)max, scrollBarProc, 0L);											wi->type = scrollBarProc;									wi->func = updateFunc;			wi->charCode = -1;			}		else {			printf("menu: bad keyword %lx\n", ty);			}		}	return ( (qItem) wo );	}	static qItem	isetval(ev, wo, slot, val)	Env				*ev;	Wino			*wo;	long			slot;	long			val;	{	int					oval;	ControlHandle		ctl;	qList				*argList;	qItem				func;		TRACE(1,("isetval: ev=%lx wo=%lx slot=%ld val=%ld\n",ev,wo,slot,val));		if (Type(wo) != qIstructType ||			wo->type != qWinoSubType)		{		printf("isetval: not wino %lx\n",wo);		return (NIL);		}			if (slot < 0 || slot >= wo->nitems)		{		printf("isetval: slot out of range %ld\n",slot);		return (NIL);		}			ctl = wo->witems[slot].control;	func = wo->witems[slot].func;	oval = GetCtlValue(ctl);	SetCtlValue(ctl, (int)val);	if (! Nullp(func))		{		argList = List2(ev, NIL, val);		Apply(ev, func, argList);		FreeList(ev, argList);		}			return (Numify(oval));	}	qItem	ihideWino(wo)	Wino	*wo;	{	if (Type(wo) != qIstructType ||			wo->type != qWinoSubType)		{		printf("ihideWino: not wino %lx\n",wo);		return (NIL);		}			HideWindow(wo->window);	return (NIL);	}qItem	ishowWino(wo)	Wino	*wo;	{	if (Type(wo) != qIstructType ||			wo->type != qWinoSubType)		{		printf("ishowWino: not wino %lx\n",wo);		return (NIL);		}			ShowWindow(wo->window);	return (NIL);	}qItem	iselectWino(wo)	Wino	*wo;	{	if (Type(wo) != qIstructType ||			wo->type != qWinoSubType)		{		printf("iselectWino: not wino %lx\n",wo);		return (NIL);		}			SelectWindow(wo->window);	return (NIL);	}	/* --------------------------------------------------------------------- */static qList	*winoList;static Wino		*curWino;static Env		*evGlobal;		static qItem	ishow(ev, wl, idleFunc)	Env			*ev;	qList		*wl;	qItem		idleFunc;	{	evGlobal = ev;	winoList = wl;		while (showLoop(ev, wl, idleFunc));		return (NIL);	}static	showLoop(ev, wl, idleFunc)	Env			*ev;	qList		*wl;	qItem		idleFunc;	{	EventRecord	myEvent;	int			mr;			if (! Nullp(idleFunc))		{		if (Nullp(Apply(ev, idleFunc, NIL)) )			mr = 0;		}			SystemTask();	if (GetNextEvent(everyEvent, &myEvent) == FALSE)		return (1);		mr = 1;	switch (myEvent.what) 		{		case mouseDown:			mr = DoMouseDown(ev, &myEvent);			break;		case keyDown:		case autoKey:			mr = DoKeyDown(ev, &myEvent);			break;		case activateEvt:			mr = DoActiveate(ev, &myEvent);			break;		case updateEvt:			mr = DoUpdate(ev, &myEvent);			break;		default:			break;		}	return ( mr );	}Rect			dragRect = { 0, 0, 1024, 1024 };DoMouseDown(ev, evt)	Env			*ev;	EventRecord	*evt;	{	WindowPtr		whichWindow;	int				op;		TRACE(1,("DoMouseDown:\n"));		op = FindWindow(evt->where, &whichWindow);	TRACE(1,("op=%d\n", op));	switch (op)		{		case inGoAway:#if 0			if (ours(whichWindow))				{				TrackGoAway(ds->view->window, evt->where);				CloseView(ds->view);				}#endif			break;		case inMenuBar:			return( DoCommand( MenuSelect(evt->where) ));			break;		case inSysWindow:			SystemClick(evt, whichWindow);			break;		case inDrag:			DragWindow(whichWindow, evt->where, &dragRect);#if 0				SetPort(ds->view->window);				NewViewRect(ds->view);#endif			break;		case inGrow:#if 0			if (ours(whichWindow))				GrowView(ev, evt, curWino);#endif			break;		case inContent:			if (whichWindow != FrontWindow())				{				SelectWindow(whichWindow);				}			else {				if (ours(whichWindow))					DoContent(ev, evt, curWino);				}			break;		}	return (1);	}	DoUpdate(ev, event)	Env				*ev;	EventRecord		*event;	{	TRACE(1,("DoUpdate\n"));		if (ours((WindowPtr)event->message))		UpdateWino(curWino);			return (1);	}UpdateWino(wo)	Wino	*wo;	{	register WindowPtr	*window = wo->window;		TRACE(1,("UpdateWino: wo=%lx\n",wo));		BeginUpdate(window);		/*DrawGrowIcon(window);*/		DrawControls(window);		/* For each update func call it */			EndUpdate(window);	}	DoActiveate(ev, event)	Env				*ev;	EventRecord		*event;	{	Rect			r;		if (! ours((WindowPtr)event->message))		return (1);	r = curWino->window->portRect;#if 0	r.top = r.bottom - (SBarWidth+1);	r.left = r.left - (SBarWidth+1);		/* ???? */	InvalRect(&r);	if (event->modifiers & activeFlag)		{		ShowControl(ds->view->scrollControl);		}	else {		HideControl(ds->view->scrollControl);		}#endif	return (1);	}	DoKeyDown(ev, evt) 	Env			*ev;	EventRecord	*evt;	{	char	theChar;	WinoItem	*wi;	WinoItem	*FindWinoItemByChar();		theChar = evt->message & charCodeMask;		if (theChar == 0x0d)		return (0);			if ((evt->modifiers & cmdKey) != 0)		{		DoCommand(MenuKey(theChar));		}	else {		if (ours(FrontWindow()) )			{			wi = FindWinoItemByChar(curWino, theChar);			if (wi)				{				Apply(ev, wi->func, NIL);				}			}		}	return (1);	}	static WinoItem	*FindWinoItemByChar(wo, ch)	Wino		*wo;	int			ch;	{	register WinoItem	*wi = &wo->witems[0];	register int	n;		for (n = wo->nitems; n > 0; n--, wi++)		{		if (wi->charCode == ch)			return (wi);		}	return ((WinoItem *) NULL);	}	int DoCommand( mResult )	long mResult;	{	int		theItem;	Str255	name;		theItem = LoWord( mResult );	switch (HiWord(mResult))		{#if 0		case appleID:			GetItem(myMenus[appleM], theItem, &name);			OpenDeskAcc( &name );			break;		case fileID:			DoFile(ds, theItem);			break;		case editID:			DoEdit(ds, theItem);			break;#endif			} 	HiliteMenu( 0 );	return ( 1 );	}	ours(w)	WindowPtr	w;	{	register qList		*lp;	register Wino		*wo;		TRACE(1,("ours: w=%lx\n"));		if (w == NULL)		return (FALSE);			curWino = (Wino *) NULL;		for (lp = winoList; Listp(lp); lp = Cdr(lp) )		{		wo = (Wino *) Car(lp);		if (Type(wo) != qIstructType || wo->type != qWinoSubType)			{			printf("ours: not wino %lx\n", wo);			continue;			}		if (wo->window == w)			{			curWino = wo;			SetPort(wo->window);						return (TRUE);			}		}	return (FALSE);	}static int scrollCode;pascal void ScrollProc();DoContent(ev, evt, wo)	Env			*ev;	EventRecord	*evt;	Wino		*wo;	{	ControlHandle	theControl;	WinoItem		*wi;	WinoItem		*FindWinoItemByControl();		TRACE(1,("DoContent: ev=%lx evt=%lx wo=%lx\n",ev, evt, wo));			GlobalToLocal(&evt->where);		scrollCode = FindControl(evt->where, wo->window, &theControl);		wi = FindWinoItemByControl(wo, theControl);		switch (scrollCode)		{		case inButton:			if (TrackControl(theControl, evt->where, 0L))				{				if (wi && wi->func != NIL)					Apply(ev, wi->func, NIL);				}			break;		case inCheckBox:			if (TrackControl(theControl, evt->where, 0L))				{				if (wi && wi->func != NIL)					{					qList 	*al;					int		n = GetCtlValue(theControl);					extern qItem	trueSym;										if (n) n = 0;					else n = 1;										SetCtlValue(theControl, n);					al = Cons(ev, n?trueSym:NIL, NIL);														Apply(ev, wi->func, al);					FreeList(ev, al);					}				}			break;								case inUpButton:		case inDownButton:		case inPageUp:		case inPageDown:			if (TrackControl(theControl, evt->where, &ScrollProc)) ;			break;		case inThumb:			if (TrackControl(theControl, evt->where, 0L))				{				ScrollProc(theControl, scrollCode);				}			break;		default:#if 0			if (PtInRect(evt->where, &view->viewRect))				SelectWord(view, ev->where);#endif			break;		}	}static WinoItem	*FindWinoItemByControl(wo, co)	Wino			*wo;	ControlHandle	*co;	{	register WinoItem	*wi = &wo->witems[0];	register int	n;		for (n = wo->nitems; n > 0; n--, wi++)		{		if (wi->control == co)			return (wi);		}	return ((WinoItem *) NULL);	}	pascal void ScrollProc(theControl, theCode)	ControlHandle	theControl;	int				theCode;	{	Env				*ev = evGlobal;	qList			*argList = (qList *) NIL;	WinoItem		*wi;	int				val;		TRACE(2,("ScrollProc: theControl=%lx theCode=%d scrollCode=%d\n",			theControl,theCode, scrollCode));				wi = FindWinoItemByControl(curWino, theControl);	if (wi && wi->func != NIL)		{			argList = List2(ev, curWino, NIL);		}			if (theCode == scrollCode)		{		val = ScrollWino(curWino, scrollCode, theControl);		if (val >= 0 && Listp(argList))			{			Rplaca(Cdr(argList), Numify(val));			Apply(ev, wi->func, argList);			}		}			FreeList(ev, argList);	}	ScrollWino(wo, scrollCode, theControl)	Wino	*wo;	int		scrollCode;	ControlHandle	theControl;	{	int		val, oval;	int		dpage;	TRACE(2,("ScrollView: wo=%lx scrollCode=%d\n",wo,scrollCode));	SetPort(wo->window);		oval = val = GetCtlValue(theControl);		switch (scrollCode)		{		case inUpButton:			val -= 1;			if (val < 0) val = 0;			break;		case inDownButton:			val += 1;			break;		case inPageUp:			val -= GetCtlMax(theControl)					/ ((wo->window->portRect.bottom 						- wo->window->portRect.top						- 2*SBarWidth)/SBarWidth);			if (val < 0) val = 0;			break;		case inPageDown:			val += GetCtlMax(theControl)					/ ((wo->window->portRect.bottom 						- wo->window->portRect.top						- 2*SBarWidth)/SBarWidth);			break;		}	SetCtlValue(theControl, val);		if (oval != val || scrollCode == inThumb)		return (val);	return (-1);	}	MoveThumb(wo)	register Wino	*wo;	{#if 0	EraseRect(&view->viewRect);	InvalRect(&view->viewRect);#endif	}			